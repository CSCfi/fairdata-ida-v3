import { CancelablePromise } from 'cancelable-promise';
import { FileStat } from 'webdav';
import { TypedEventTarget } from 'typescript-event-target';
import { WebDAVClient } from 'webdav';

declare interface ActionContext {
    folder: Folder;
}

/**
 * Add a new menu entry to the upload manager menu
 *
 * @param entry The new file menu entry
 */
export declare const addNewFileMenuEntry: (entry: Entry) => void;

declare interface Attribute {
    [key: string]: any;
}

export declare class Column implements ColumnData {
    private _column;
    constructor(column: ColumnData);
    get id(): string;
    get title(): string;
    get render(): (node: Node_2, view: View) => HTMLElement;
    get sort(): ((nodeA: Node_2, nodeB: Node_2) => number) | undefined;
    get summary(): ((node: Node_2[], view: View) => string) | undefined;
}

declare interface ColumnData {
    /** Unique column ID */
    id: string;
    /** Translated column title */
    title: string;
    /** The content of the cell. The element will be appended within */
    render: (node: Node_2, view: View) => HTMLElement;
    /** Function used to sort Nodes between them */
    sort?: (nodeA: Node_2, nodeB: Node_2) => number;
    /**
     * Custom summary of the column to display at the end of the list.
     * Will not be displayed if  nothing is provided
     */
    summary?: (node: Node_2[], view: View) => string;
}

export declare type ContentsWithRoot = {
    folder: Folder;
    contents: Node_2[];
};

/**
 * Get a WebDAV client configured to include the Nextcloud request token
 *
 * @param remoteURL The DAV server remote URL
 * @param headers Optional additional headers to set for every request
 */
export declare const davGetClient: (remoteURL?: string, headers?: Record<string, string>) => WebDAVClient;

/**
 * Get the default PROPFIND request body
 */
export declare const davGetDefaultPropfind: () => string;

/**
 * Get the REPORT body to filter for favorite nodes
 */
export declare const davGetFavoritesReport: () => string;

/**
 * Get the SEARCH body to search for recently modified files
 *
 * @param lastModified Oldest timestamp to include (Unix timestamp)
 * @example
 * ```ts
 * // SEARCH for recent files need a different DAV endpoint
 * const client = davGetClient(generateRemoteUrl('dav'))
 * // Timestamp of last week
 * const lastWeek = Math.round(Date.now() / 1000) - (60 * 60 * 24 * 7)
 * const contentsResponse = await client.getDirectoryContents(path, {
 *     details: true,
 *     data: davGetRecentSearch(lastWeek),
 *     headers: {
 *         method: 'SEARCH',
 *         'Content-Type': 'application/xml; charset=utf-8',
 *     },
 *     deep: true,
 * }) as ResponseDataDetailed<FileStat[]>
 * ```
 */
export declare const davGetRecentSearch: (lastModified: number) => string;

/**
 * Get the DAV remote URL used as base URL for the WebDAV client
 * It also handles public shares
 */
export declare function davGetRemoteURL(): string;

/**
 * Get the DAV root path for the current user or public share
 */
export declare function davGetRootPath(): string;

/**
 * Parse the WebDAV permission string to a permission enum
 *
 * @param permString The DAV permission string
 */
export declare const davParsePermissions: (permString?: string) => number;

export declare type DavProperty = {
    [key: string]: string;
};

/**
 * The DAV remote URL used as base URL for the WebDAV client
 * This is a cached version of `getRemoteURL`
 */
export declare const davRemoteURL: string;

/**
 * Covert DAV result `FileStat` to `Node`
 *
 * @param node The DAV result
 * @param filesRoot The DAV files root path
 * @param remoteURL The DAV server remote URL (same as on `getClient`)
 */
export declare const davResultToNode: (node: FileStat, filesRoot?: string, remoteURL?: string) => Node_2;

/**
 * The DAV root path for the current user
 * This is a cached version of `getRemoteURL`
 */
export declare const davRootPath: string;

export declare const defaultDavNamespaces: {
    d: string;
    nc: string;
    oc: string;
    ocs: string;
};

export declare const defaultDavProperties: string[];

export declare enum DefaultType {
    DEFAULT = "default",
    HIDDEN = "hidden"
}

export declare interface Entry {
    /** Unique ID */
    id: string;
    /**
     * Category to put this entry in
     * (supported since Nextcloud 30)
     * @since 3.3.0
     * @default NewMenuEntryCategory.CreateNew
     */
    category?: NewMenuEntryCategory;
    /** Translatable string displayed in the menu */
    displayName: string;
    /**
     * Condition wether this entry is shown or not
     * @param context the creation context. Usually the current folder
     */
    enabled?: (context: Folder) => boolean;
    /**
     * Either iconSvgInline or iconClass must be defined
     * Svg as inline string. <svg><path fill="..." /></svg>
     */
    iconSvgInline?: string;
    /**
     * Existing icon css class
     * @deprecated use iconSvgInline instead
     */
    iconClass?: string;
    /** Order of the entry in the menu */
    order?: number;
    /**
     * Function to be run after creation
     * @param context the creation context. Usually the current folder
     * @param content list of file/folders present in the context folder
     */
    handler: (context: Folder, content: Node_2[]) => void;
}

declare class File_2 extends Node_2 {
    get type(): FileType;
    /**
     * Returns a clone of the file
     */
    clone(): File_2;
}
export { File_2 as File }

export declare class FileAction {
    private _action;
    constructor(action: FileActionData);
    get id(): string;
    get displayName(): (files: Node_2[], view: View) => string;
    get title(): ((files: Node_2[], view: View) => string) | undefined;
    get iconSvgInline(): (files: Node_2[], view: View) => string;
    get enabled(): ((files: Node_2[], view: View) => boolean) | undefined;
    get exec(): (file: Node_2, view: View, dir: string) => Promise<boolean | null>;
    get execBatch(): ((files: Node_2[], view: View, dir: string) => Promise<(boolean | null)[]>) | undefined;
    get order(): number | undefined;
    get parent(): string | undefined;
    get default(): DefaultType | undefined;
    get destructive(): boolean | undefined;
    get inline(): ((file: Node_2, view: View) => boolean) | undefined;
    get renderInline(): ((file: Node_2, view: View) => Promise<HTMLElement | null>) | undefined;
    private validateAction;
}

declare interface FileActionData {
    /** Unique ID */
    id: string;
    /** Translatable string displayed in the menu */
    displayName: (files: Node_2[], view: View) => string;
    /** Translatable title for of the action */
    title?: (files: Node_2[], view: View) => string;
    /** Svg as inline string. <svg><path fill="..." /></svg> */
    iconSvgInline: (files: Node_2[], view: View) => string;
    /** Condition wether this action is shown or not */
    enabled?: (files: Node_2[], view: View) => boolean;
    /**
     * Function executed on single file action
     * @return true if the action was executed successfully,
     * false otherwise and null if the action is silent/undefined.
     * @throws Error if the action failed
     */
    exec: (file: Node_2, view: View, dir: string) => Promise<boolean | null>;
    /**
     * Function executed on multiple files action
     * @return true if the action was executed successfully,
     * false otherwise and null if the action is silent/undefined.
     * @throws Error if the action failed
     */
    execBatch?: (files: Node_2[], view: View, dir: string) => Promise<(boolean | null)[]>;
    /** This action order in the list */
    order?: number;
    /**
     * Set to true if this action is a destructive action, like "delete".
     * This will change the appearance in the action menu more prominent (e.g. red colored)
     */
    destructive?: boolean;
    /**
     * This action's parent id in the list.
     * If none found, will be displayed as a top-level action.
     */
    parent?: string;
    /**
     * Make this action the default.
     * If multiple actions are default, the first one
     * will be used. The other ones will be put as first
     * entries in the actions menu iff DefaultType.Hidden is not used.
     * A DefaultType.Hidden action will never be shown
     * in the actions menu even if another action takes
     * its place as default.
     */
    default?: DefaultType;
    /**
     * If true, the renderInline function will be called
     */
    inline?: (file: Node_2, view: View) => boolean;
    /**
     * If defined, the returned html element will be
     * appended before the actions menu.
     */
    renderInline?: (file: Node_2, view: View) => Promise<HTMLElement | null>;
}

export declare class FileListAction {
    private _action;
    constructor(action: FileListActionData);
    get id(): string;
    get displayName(): (view: View) => string;
    get iconSvgInline(): (view: View) => string;
    get order(): number;
    get enabled(): ((view: View, nodes: Node_2[], context: ActionContext) => boolean) | undefined;
    get exec(): (view: View, nodes: Node_2[], context: ActionContext) => Promise<void>;
    private validateAction;
}

declare interface FileListActionData {
    /** Unique ID */
    id: string;
    /** Translated name of the action */
    displayName: (view: View) => string;
    /** Raw svg string */
    iconSvgInline: (view: View) => string;
    /** Sort order */
    order: number;
    /**
     * Returns true if this action shoud be shown
     *
     * @param nodes The nodes in the current directory
     * @param context The context
     * @param context.folder The current folder
     */
    enabled?: (view: View, nodes: Node_2[], context: ActionContext) => boolean;
    /**
     * Function to execute
     *
     * @param nodes The nodes in the current directory
     * @param context The context
     * @param context.folder The current folder
     */
    exec: (view: View, nodes: Node_2[], context: ActionContext) => Promise<void>;
}

export declare class FileListFilter extends TypedEventTarget<IFileListFilterEvents> implements IFileListFilter {
    id: string;
    order: number;
    constructor(id: string, order?: number);
    filter(nodes: INode[]): INode[];
    protected updateChips(chips: IFileListFilterChip[]): void;
    protected filterUpdated(): void;
}

export declare enum FilesSortingMode {
    Name = "basename",
    Modified = "mtime",
    Size = "size"
}

export declare interface FilesSortingOptions {
    /**
     * They key to order the files by
     * @default FilesSortingMode.Name
     */
    sortingMode?: FilesSortingMode;
    /**
     * @default 'asc'
     */
    sortingOrder?: SortingOrder;
    /**
     * If set to true nodes marked as favorites are ordered on top of all other nodes
     * @default false
     */
    sortFavoritesFirst?: boolean;
    /**
     * If set to true folders are ordered on top of files
     * @default false
     */
    sortFoldersFirst?: boolean;
}

/**
 * SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
export declare enum FileType {
    Folder = "folder",
    File = "file"
}

/**
 * This event is emitted when the the filter value changed and the file list needs to be updated
 */
export declare interface FilterUpdateChipsEvent extends CustomEvent<IFileListFilterChip[]> {
    type: 'update:chips';
}

/**
 * This event is emitted when the the filter value changed and the file list needs to be updated
 */
export declare interface FilterUpdateEvent extends CustomEvent<never> {
    type: 'update:filter';
}

export declare class Folder extends Node_2 {
    constructor(data: NodeData);
    get type(): FileType;
    get extension(): string | null;
    get mime(): string;
    /**
     * Returns a clone of the folder
     */
    clone(): Node_2;
}

/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * Format a file size in a human-like format. e.g. 42GB
 *
 * The default for Nextcloud is like Windows using binary sizes but showing decimal units,
 * meaning 1024 bytes will show as 1KB instead of 1KiB or like on Apple 1.02 KB
 *
 * @param size in bytes
 * @param skipSmallSizes avoid rendering tiny sizes and return '< 1 KB' instead
 * @param binaryPrefixes True if size binary prefixes like `KiB` should be used as per IEC 80000-13
 * @param base1000 Set to true to use base 1000 as per SI or used by Apple (default is base 1024 like Linux or Windows)
 */
export declare function formatFileSize(size: number | string, skipSmallSizes?: boolean, binaryPrefixes?: boolean, base1000?: boolean): string;

/**
 * Get the registered dav namespaces
 */
export declare const getDavNameSpaces: () => string;

/**
 * Get the registered dav properties
 */
export declare const getDavProperties: () => string;

/**
 * Use WebDAV to query for favorite Nodes
 *
 * @param davClient The WebDAV client to use for performing the request
 * @param path Base path for the favorites, if unset all favorites are queried
 * @param davRoot The root path for the DAV user (defaults to `defaultRootPath`)
 * @example
 * ```js
 * import { getClient, defaultRootPath, getFavoriteNodes } from '@nextcloud/files'
 *
 * const client = getClient()
 * // query favorites for the root
 * const favorites = await getFavoriteNodes(client)
 * // which is the same as writing:
 * const favorites = await getFavoriteNodes(client, '/', defaultRootPath)
 * ```
 */
export declare const getFavoriteNodes: (davClient: WebDAVClient, path?: string, davRoot?: string) => CancelablePromise<Node_2[]>;

export declare const getFileActions: () => FileAction[];

export declare const getFileListActions: () => FileListAction[];

/**
 * Get all registered file list filters
 */
export declare function getFileListFilters(): IFileListFilter[];

export declare const getFileListHeaders: () => Header[];

/**
 * Get the current files navigation
 */
export declare const getNavigation: () => Navigation;

/**
 * Get the list of registered entries from the upload menu
 *
 * @param {Folder} context the creation context. Usually the current folder FileInfo
 */
export declare const getNewFileMenuEntries: (context?: Folder) => Entry[];

/**
 * Create an unique file name
 * @param name The initial name to use
 * @param otherNames Other names that are already used
 * @param options Optional parameters for tuning the behavior
 * @return {string} Either the initial name, if unique, or the name with the suffix so that the name is unique
 */
export declare function getUniqueName(name: string, otherNames: string[], options?: UniqueNameOptions): string;

export declare class Header {
    private _header;
    constructor(header: HeaderData);
    get id(): string;
    get order(): number;
    get enabled(): ((folder: Folder, view: View) => boolean) | undefined;
    get render(): (el: HTMLElement, folder: Folder, view: View) => void;
    get updated(): (folder: Folder, view: View) => any;
    private validateHeader;
}

declare interface HeaderData {
    /** Unique ID */
    id: string;
    /** Order */
    order: number;
    /** Condition wether this header is shown or not */
    enabled?: (folder: Folder, view: View) => boolean;
    /** Executed when file list is initialized */
    render: (el: HTMLElement, folder: Folder, view: View) => void;
    /** Executed when root folder changed */
    updated(folder: Folder, view: View): any;
}

declare type IdentifierFn<T> = (v: T) => unknown;

/**
 * Interface of the File class
 */
export declare interface IFile extends INode {
    readonly type: FileType.File;
}

export declare interface IFileListFilter extends TypedEventTarget<IFileListFilterEvents> {
    /**
     * Unique ID of this filter
     */
    readonly id: string;
    /**
     * Order of the filter
     *
     * Use a low number to make this filter ordered in front.
     */
    readonly order: number;
    /**
     * Filter function to decide if a node is shown.
     *
     * @param nodes Nodes to filter
     * @return Subset of the `nodes` parameter to show
     */
    filter(nodes: INode[]): INode[];
    /**
     * If the filter needs a visual element for settings it can provide a function to mount it.
     * @param el The DOM element to mount to
     */
    mount?(el: HTMLElement): void;
    /**
     * Reset the filter to the initial state.
     * This is called by the files app.
     * Implementations should make sure,that if they provide chips they need to emit the `update:chips` event.
     *
     * @since 3.10.0
     */
    reset?(): void;
}

/**
 * Active filters can provide one or more "chips" to show the currently active state.
 * Must at least provide a text representing the filters state and a callback to unset that state (disable this filter).
 */
export declare interface IFileListFilterChip {
    /**
     * Text of the chip
     */
    text: string;
    /**
     * Optional icon to be used on the chip (inline SVG as string)
     */
    icon?: string;
    /**
     * Optional pass a user id to use a user avatar instead of an icon
     */
    user?: string;
    /**
     * Handler to be called on click
     */
    onclick: () => void;
}

declare interface IFileListFilterEvents {
    [name: string]: CustomEvent;
    'update:filter': FilterUpdateEvent;
    'update:chips': FilterUpdateChipsEvent;
}

/**
 * Interface of the folder class
 */
export declare interface IFolder extends INode {
    readonly type: FileType.Folder;
    readonly extension: null;
    readonly mime: 'httpd/unix-directory';
}

/**
 * Interface of the node class
 */
export declare type INode = Pick<Node_2, keyof Node_2>;

export declare class InvalidFilenameError extends Error {
    constructor(options: InvalidFilenameErrorOptions);
    /**
     * The filename that was validated
     */
    get filename(): string;
    /**
     * Reason why the validation failed
     */
    get reason(): InvalidFilenameErrorReason;
    /**
     * Part of the filename that caused this error
     */
    get segment(): string;
}

declare interface InvalidFilenameErrorOptions {
    /**
     * The filename that was validated
     */
    filename: string;
    /**
     * Reason why the validation failed
     */
    reason: InvalidFilenameErrorReason;
    /**
     * Part of the filename that caused this error
     */
    segment: string;
}

/**
 * SPDX-FileCopyrightText: Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later or LGPL-3.0-or-later
 */
export declare enum InvalidFilenameErrorReason {
    ReservedName = "reserved name",
    Character = "character",
    Extension = "extension"
}

/**
 * Check the validity of a filename
 * This is a convinient wrapper for `checkFilenameValidity` to only return a boolean for the valid
 * @param filename Filename to check validity
 */
export declare function isFilenameValid(filename: string): boolean;

/**
 * The files navigation manages the available and active views
 *
 * Custom views for the files app can be registered (examples are the favorites views or the shared-with-you view).
 * It is also possible to listen on changes of the registered views or when the current active view is changed.
 * @example
 * ```js
 * const navigation = getNavigation()
 * navigation.addEventListener('update', () => {
 *     // This will be called whenever a new view is registered or a view is removed
 *     const viewNames = navigation.views.map((view) => view.name)
 *     console.warn('Registered views changed', viewNames)
 * })
 * // Or you can react to changes of the current active view
 * navigation.addEventListener('updateActive', (event) => {
 *     // This will be called whenever the active view changed
 *     const newView = event.detail // you could also use `navigation.active`
 *     console.warn('Active view changed to ' + newView.name)
 * })
 * ```
 */
export declare class Navigation extends TypedEventTarget<{
    updateActive: UpdateActiveViewEvent;
    update: UpdateViewsEvent;
}> {
    private _views;
    private _currentView;
    /**
     * Register a new view on the navigation
     * @param view The view to register
     * @throws `Error` is thrown if a view with the same id is already registered
     */
    register(view: View): void;
    /**
     * Remove a registered view
     * @param id The id of the view to remove
     */
    remove(id: string): void;
    /**
     * Set the currently active view
     * @fires UpdateActiveViewEvent
     * @param view New active view
     */
    setActive(view: View | null): void;
    /**
     * The currently active files view
     */
    get active(): View | null;
    /**
     * All registered views
     */
    get views(): View[];
}

export declare enum NewMenuEntryCategory {
    /**
     * For actions where the user is intended to upload from their device
     */
    UploadFromDevice = 0,
    /**
     * For actions that create new nodes on the server without uploading
     */
    CreateNew = 1,
    /**
     * For everything not matching the other categories
     */
    Other = 2
}

declare abstract class Node_2 {
    private _data;
    private _attributes;
    private _knownDavService;
    private readonlyAttributes;
    private handler;
    constructor(data: NodeData, davService?: RegExp);
    /**
     * Get the source url to this object
     * There is no setter as the source is not meant to be changed manually.
     * You can use the rename or move method to change the source.
     */
    get source(): string;
    /**
     * Get the encoded source url to this object for requests purposes
     */
    get encodedSource(): string;
    /**
     * Get this object name
     * There is no setter as the source is not meant to be changed manually.
     * You can use the rename or move method to change the source.
     */
    get basename(): string;
    /**
     * The nodes displayname
     * By default the display name and the `basename` are identical,
     * but it is possible to have a different name. This happens
     * on the files app for example for shared folders.
     */
    get displayname(): string;
    /**
     * Set the displayname
     */
    set displayname(displayname: string);
    /**
     * Get this object's extension
     * There is no setter as the source is not meant to be changed manually.
     * You can use the rename or move method to change the source.
     */
    get extension(): string | null;
    /**
     * Get the directory path leading to this object
     * Will use the relative path to root if available
     *
     * There is no setter as the source is not meant to be changed manually.
     * You can use the rename or move method to change the source.
     */
    get dirname(): string;
    /**
     * Is it a file or a folder ?
     */
    abstract get type(): FileType;
    /**
     * Get the file mime
     * There is no setter as the mime is not meant to be changed
     */
    get mime(): string | undefined;
    /**
     * Get the file modification time
     */
    get mtime(): Date | undefined;
    /**
     * Set the file modification time
     */
    set mtime(mtime: Date | undefined);
    /**
     * Get the file creation time
     * There is no setter as the creation time is not meant to be changed
     */
    get crtime(): Date | undefined;
    /**
     * Get the file size
     */
    get size(): number | undefined;
    /**
     * Set the file size
     */
    set size(size: number | undefined);
    /**
     * Get the file attribute
     * This contains all additional attributes not provided by the Node class
     */
    get attributes(): Attribute;
    /**
     * Get the file permissions
     */
    get permissions(): Permission;
    /**
     * Set the file permissions
     */
    set permissions(permissions: Permission);
    /**
     * Get the file owner
     * There is no setter as the owner is not meant to be changed
     */
    get owner(): string | null;
    /**
     * Is this a dav-related ressource ?
     */
    get isDavRessource(): boolean;
    /**
     * Get the dav root of this object
     * There is no setter as the root is not meant to be changed
     */
    get root(): string | null;
    /**
     * Get the absolute path of this object relative to the root
     */
    get path(): string;
    /**
     * Get the node id if defined.
     * There is no setter as the fileid is not meant to be changed
     */
    get fileid(): number | undefined;
    /**
     * Get the node status.
     */
    get status(): NodeStatus | undefined;
    /**
     * Set the node status.
     */
    set status(status: NodeStatus | undefined);
    /**
     * Get the node data
     */
    get data(): NodeData;
    /**
     * Move the node to a new destination
     *
     * @param {string} destination the new source.
     * e.g. https://cloud.domain.com/remote.php/dav/files/emma/Photos/picture.jpg
     */
    move(destination: string): void;
    /**
     * Rename the node
     * This aliases the move method for easier usage
     *
     * @param basename The new name of the node
     */
    rename(basename: string): void;
    /**
     * Update the mtime if exists
     */
    updateMtime(): void;
    /**
     * Update the attributes of the node
     * Warning, updating attributes will NOT automatically update the mtime.
     *
     * @param attributes The new attributes to update on the Node attributes
     */
    update(attributes: Attribute): void;
    /**
     * Returns a clone of the node
     */
    abstract clone(): Node_2;
}
export { Node_2 as Node }

export declare interface NodeData {
    /** Unique ID */
    id?: number;
    /**
     * URL to the ressource.
     * e.g. https://cloud.domain.com/remote.php/dav/files/emma/Photos/picture.jpg
     * or https://domain.com/Photos/picture.jpg
     */
    source: string;
    /** Last modified time */
    mtime?: Date;
    /** Creation time */
    crtime?: Date;
    /** The mime type Optional for folders only */
    mime?: string;
    /** The node size type */
    size?: number;
    /** The node permissions */
    permissions?: Permission;
    /** The owner  UID of this node */
    owner: string | null;
    /** Optional the displayname of this node */
    displayname?: string;
    /** The node attributes */
    attributes?: Attribute;
    /**
     * The absolute root of the home relative to the service.
     * It is highly recommended to provide that information.
     * e.g. /files/emma
     */
    root?: string;
    /** The node status */
    status?: NodeStatus;
}

export declare enum NodeStatus {
    /** This is a new node and it doesn't exists on the filesystem yet */
    NEW = "new",
    /** This node has failed and is unavailable  */
    FAILED = "failed",
    /** This node is currently loading or have an operation in progress */
    LOADING = "loading",
    /** This node is locked and cannot be modified */
    LOCKED = "locked"
}

/**
 * Natural order a collection
 * You can define identifiers as callback functions, that get the element and return the value to sort.
 *
 * @param collection The collection to order
 * @param identifiers An array of identifiers to use, by default the identity of the element is used
 * @param orders Array of orders, by default all identifiers are sorted ascening
 */
export declare function orderBy<T>(collection: readonly T[], identifiers?: IdentifierFn<T>[], orders?: SortingOrder[]): T[];

/**
 * Returns a file size in bytes from a humanly readable string
 * Note: `b` and `B` are both parsed as bytes and not as bit or byte.
 *
 * @param  {string} value file size in human-readable format
 * @param  {boolean} forceBinary for backwards compatibility this allows values to be base 2 (so 2KB means 2048 bytes instead of 2000 bytes)
 * @return {number} or null if string could not be parsed
 */
export declare function parseFileSize(value: string, forceBinary?: boolean): number | null;

/**
 * SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * Node permissions
 */
export declare enum Permission {
    NONE = 0,
    CREATE = 4,
    READ = 1,
    UPDATE = 2,
    DELETE = 8,
    SHARE = 16,
    ALL = 31
}

/**
 * Register custom DAV properties
 *
 * Can be used if your app introduces custom DAV properties, so e.g. the files app can make use of it.
 *
 * @param prop The property
 * @param namespace The namespace of the property
 */
export declare const registerDavProperty: (prop: string, namespace?: DavProperty) => boolean;

export declare const registerFileAction: (action: FileAction) => void;

export declare const registerFileListAction: (action: FileListAction) => void;

/**
 * Register a new filter on the file list
 *
 * This only must be called once to register the filter,
 * when the filter state changes you need to call `filterUpdated` on the filter instead.
 *
 * @param filter The filter to register on the file list
 */
export declare function registerFileListFilter(filter: IFileListFilter): void;

export declare const registerFileListHeaders: (header: Header) => void;

/**
 * Remove a previously registered entry from the upload menu
 *
 * @param entry Entry to remove (or name of entry)
 */
export declare const removeNewFileMenuEntry: (entry: Entry | string) => void;

export declare type SortingOrder = 'asc' | 'desc';

/**
 * Sort files and folders according to the sorting options
 * @param nodes Nodes to sort
 * @param options Sorting options
 */
export declare function sortNodes(nodes: readonly INode[], options?: FilesSortingOptions): INode[];

/**
 * SPDX-FileCopyrightText: Ferdinand Thiessen <opensource@fthiessen.de>
 * SPDX-License-Identifier: AGPL-3.0-or-later or LGPL-3.0-or-later
 */
declare interface UniqueNameOptions {
    /**
     * A function that takes an index and returns a suffix to add to the file name, defaults to '(index)'
     * @param index The current index to add
     */
    suffix?: (index: number) => string;
    /**
     * Set to true to ignore the file extension when adding the suffix (when getting a unique directory name)
     */
    ignoreFileExtension?: boolean;
}

/**
 * Remove a registered filter from the file list
 * @param filterId The unique ID of the filter to remove
 */
export declare function unregisterFileListFilter(filterId: string): void;

/**
 * The event is emitted when the navigation view was updated.
 * It contains the new active view in the `detail` attribute.
 */
declare interface UpdateActiveViewEvent extends CustomEvent<View | null> {
    type: 'updateActive';
}

/**
 * This event is emitted when the list of registered views is changed
 */
declare interface UpdateViewsEvent extends CustomEvent<never> {
    type: 'update';
}

/**
 * Validate a given filename
 * @param filename The filename to check
 * @throws {InvalidFilenameError}
 */
export declare function validateFilename(filename: string): void;

export declare class View implements ViewData {
    private _view;
    constructor(view: ViewData);
    get id(): string;
    get name(): string;
    get caption(): string | undefined;
    get emptyTitle(): string | undefined;
    get emptyCaption(): string | undefined;
    get getContents(): (path: string) => Promise<ContentsWithRoot>;
    get icon(): string;
    set icon(icon: string);
    get order(): number | undefined;
    set order(order: number | undefined);
    get params(): Record<string, string> | undefined;
    set params(params: Record<string, string> | undefined);
    get columns(): Column[] | undefined;
    get emptyView(): ((div: HTMLDivElement) => void) | undefined;
    get parent(): string | undefined;
    get sticky(): boolean | undefined;
    get expanded(): boolean | undefined;
    set expanded(expanded: boolean | undefined);
    get defaultSortKey(): string | undefined;
    get loadChildViews(): ((view: View) => Promise<void>) | undefined;
}

declare interface ViewData {
    /** Unique view ID */
    id: string;
    /** Translated view name */
    name: string;
    /** Translated accessible description of the view */
    caption?: string;
    /** Translated title of the empty view */
    emptyTitle?: string;
    /** Translated description of the empty view */
    emptyCaption?: string;
    /**
     * Method return the content of the  provided path
     * This ideally should be a cancellable promise.
     * promise.cancel(reason) will be called when the directory
     * change and the promise is not resolved yet.
     * You _must_ also return the current directory
     * information alongside with its content.
     */
    getContents: (path: string) => Promise<ContentsWithRoot>;
    /** The view icon as an inline svg */
    icon: string;
    /**
     * The view order.
     * If not set will be natural sorted by view name.
     */
    order?: number;
    /**
     * Custom params to give to the router on click
     * If defined, will be treated as a dummy view and
     * will just redirect and not fetch any contents.
     */
    params?: Record<string, string>;
    /**
     * This view column(s). Name and actions are
     * by default always included
     */
    columns?: Column[];
    /** The empty view element to render your empty content into */
    emptyView?: (div: HTMLDivElement) => void;
    /** The parent unique ID */
    parent?: string;
    /** This view is sticky (sent at the bottom) */
    sticky?: boolean;
    /**
     * This view has children and is expanded (by default)
     * or not. This will be overridden by user config.
     */
    expanded?: boolean;
    /**
     * Will be used as default if the user
     * haven't customized their sorting column
     */
    defaultSortKey?: string;
    /**
     * Method called to load child views if any
     */
    loadChildViews?: (view: View) => Promise<void>;
}

export { }
