--- /var/ida/nextcloud-new/lib/private/Files/Cache/Scanner.php	2024-11-05 08:30:09.645707031 +0000
+++ /var/ida/nextcloud-old/lib/private/Files/Cache/Scanner.php.original	2024-02-20 10:11:39.286443297 +0000
@@ -1,24 +1,48 @@
 <?php
-
 /**
- * SPDX-FileCopyrightText: 2016-2024 Nextcloud GmbH and Nextcloud contributors
- * SPDX-FileCopyrightText: 2016 ownCloud, Inc.
- * SPDX-License-Identifier: AGPL-3.0-only
+ * @copyright Copyright (c) 2016, ownCloud, Inc.
+ *
+ * @author Ari Selseng <ari@selseng.net>
+ * @author Arthur Schiwon <blizzz@arthur-schiwon.de>
+ * @author Björn Schießle <bjoern@schiessle.org>
+ * @author Christoph Wurst <christoph@winzerhof-wurst.at>
+ * @author Daniel Jagszent <daniel@jagszent.de>
+ * @author Joas Schilling <coding@schilljs.com>
+ * @author Jörn Friedrich Dreyer <jfd@butonic.de>
+ * @author Lukas Reschke <lukas@statuscode.ch>
+ * @author Martin Mattel <martin.mattel@diemattels.at>
+ * @author Morris Jobke <hey@morrisjobke.de>
+ * @author Owen Winkler <a_github@midnightcircus.com>
+ * @author Robin Appelman <robin@icewind.nl>
+ * @author Robin McCorkell <robin@mccorkell.me.uk>
+ * @author Thomas Müller <thomas.mueller@tmit.eu>
+ * @author Vincent Petry <vincent@nextcloud.com>
+ *
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program. If not, see <http://www.gnu.org/licenses/>
+ *
  */
+
 namespace OC\Files\Cache;
 
 use Doctrine\DBAL\Exception;
-use OC\Files\Storage\Wrapper\Encryption;
-use OC\Files\Storage\Wrapper\Jail;
+use OC\Files\Filesystem;
 use OC\Hooks\BasicEmitter;
-use OC\SystemConfig;
 use OCP\Files\Cache\IScanner;
 use OCP\Files\ForbiddenException;
-use OCP\Files\NotFoundException;
-use OCP\Files\Storage\IReliableEtagStorage;
-use OCP\IDBConnection;
+use OCP\ILogger;
 use OCP\Lock\ILockingProvider;
-use Psr\Log\LoggerInterface;
 
 /**
  * Class Scanner
@@ -62,18 +86,12 @@
 	 */
 	protected $lockingProvider;
 
-	protected IDBConnection $connection;
-
 	public function __construct(\OC\Files\Storage\Storage $storage) {
 		$this->storage = $storage;
 		$this->storageId = $this->storage->getId();
 		$this->cache = $storage->getCache();
-		/** @var SystemConfig $config */
-		$config = \OC::$server->get(SystemConfig::class);
-		$this->cacheActive = !$config->getValue('filesystem_cache_readonly', false);
-		$this->useTransactions = !$config->getValue('filescanner_no_transactions', false);
-		$this->lockingProvider = \OC::$server->get(ILockingProvider::class);
-		$this->connection = \OC::$server->get(IDBConnection::class);
+		$this->cacheActive = !\OC::$server->getConfig()->getSystemValue('filesystem_cache_readonly', false);
+		$this->lockingProvider = \OC::$server->getLockingProvider();
 	}
 
 	/**
@@ -96,7 +114,7 @@
 	protected function getData($path) {
 		$data = $this->storage->getMetaData($path);
 		if (is_null($data)) {
-			\OC::$server->get(LoggerInterface::class)->debug("!!! Path '$path' is not accessible or present !!!", ['app' => 'core']);
+			\OCP\Util::writeLog(Scanner::class, "!!! Path '$path' is not accessible or present !!!", ILogger::DEBUG);
 		}
 		return $data;
 	}
@@ -121,8 +139,9 @@
 				return null;
 			}
 		}
-		// only proceed if $file is not a partial file, blacklist is handled by the storage
-		if (!self::isPartialFile($file)) {
+		// only proceed if $file is not a partial file nor a blacklisted file
+		if (!self::isPartialFile($file) and !Filesystem::isFileBlacklisted($file)) {
+
 			// acquire a lock
 			if ($lock) {
 				if ($this->storage->instanceOfStorage('\OCP\Files\Storage\ILockingStorage')) {
@@ -151,7 +171,7 @@
 					}
 
 					$parent = dirname($file);
-					if ($parent === '.' || $parent === '/') {
+					if ($parent === '.' or $parent === '/') {
 						$parent = '';
 					}
 					if ($parentId === -1) {
@@ -159,7 +179,7 @@
 					}
 
 					// scan the parent if it's not in the cache (id -1) and the current file is not the root folder
-					if ($file && $parentId === -1) {
+					if ($file and $parentId === -1) {
 						$parentData = $this->scanFile($parent);
 						if (!$parentData) {
 							return null;
@@ -173,40 +193,28 @@
 						/** @var CacheEntry $cacheData */
 						$cacheData = $this->cache->get($file);
 					}
-					if ($cacheData && $reuseExisting && isset($cacheData['fileid'])) {
+					if ($cacheData and $reuseExisting and isset($cacheData['fileid'])) {
 						// prevent empty etag
-						$etag = empty($cacheData['etag']) ? $data['etag'] : $cacheData['etag'];
+						if (empty($cacheData['etag'])) {
+							$etag = $data['etag'];
+						} else {
+							$etag = $cacheData['etag'];
+						}
 						$fileId = $cacheData['fileid'];
 						$data['fileid'] = $fileId;
 						// only reuse data if the file hasn't explicitly changed
-						$mtimeUnchanged = isset($data['storage_mtime']) && isset($cacheData['storage_mtime']) && $data['storage_mtime'] === $cacheData['storage_mtime'];
-						// if the folder is marked as unscanned, never reuse etags
-						if ($mtimeUnchanged && $cacheData['size'] !== -1) {
+						if (isset($data['storage_mtime']) && isset($cacheData['storage_mtime']) && $data['storage_mtime'] === $cacheData['storage_mtime']) {
 							$data['mtime'] = $cacheData['mtime'];
 							if (($reuseExisting & self::REUSE_SIZE) && ($data['size'] === -1)) {
 								$data['size'] = $cacheData['size'];
 							}
-							if ($reuseExisting & self::REUSE_ETAG && !$this->storage->instanceOfStorage(IReliableEtagStorage::class)) {
+							if ($reuseExisting & self::REUSE_ETAG) {
 								$data['etag'] = $etag;
 							}
 						}
-
-						// we only updated unencrypted_size if it's already set
-						if ($cacheData['unencrypted_size'] === 0) {
-							unset($data['unencrypted_size']);
-						}
-
 						// Only update metadata that has changed
-						// i.e. get all the values in $data that are not present in the cache already
-						$newData = $this->array_diff_assoc_multi($data, $cacheData->getData());
-						
-						// make it known to the caller that etag has been changed and needs propagation
-						if (isset($newData['etag'])) {
-							$data['etag_changed'] = true;
-						}
+						$newData = array_diff_assoc($data, $cacheData->getData());
 					} else {
-						// we only updated unencrypted_size if it's already set
-						unset($data['unencrypted_size']);
 						$newData = $data;
 						$fileId = -1;
 					}
@@ -216,8 +224,11 @@
 						$newData['parent'] = $parentId;
 						$data['fileid'] = $this->addToCache($file, $newData, $fileId);
 					}
-
-					$data['oldSize'] = ($cacheData && isset($cacheData['size'])) ? $cacheData['size'] : 0;
+					if ($cacheData && isset($cacheData['size'])) {
+						$data['oldSize'] = $cacheData['size'];
+					} else {
+						$data['oldSize'] = 0;
+					}
 
 					if ($cacheData && isset($cacheData['encrypted'])) {
 						$data['encrypted'] = $cacheData['encrypted'];
@@ -275,7 +286,7 @@
 			$data['permissions'] = $data['scan_permissions'];
 		}
 		\OC_Hook::emit('Scanner', 'addToCache', ['file' => $path, 'data' => $data]);
-		$this->emit('\OC\Files\Cache\Scanner', 'addToCache', [$path, $this->storageId, $data, $fileId]);
+		$this->emit('\OC\Files\Cache\Scanner', 'addToCache', [$path, $this->storageId, $data]);
 		if ($this->cacheActive) {
 			if ($fileId !== -1) {
 				$this->cache->update($fileId, $data);
@@ -325,16 +336,11 @@
 			}
 		}
 		try {
-			try {
 				$data = $this->scanFile($path, $reuse, -1, null, $lock);
-				if ($data && $data['mimetype'] === 'httpd/unix-directory') {
-					$size = $this->scanChildren($path, $recursive, $reuse, $data['fileid'], $lock, $data['size']);
+			if ($data and $data['mimetype'] === 'httpd/unix-directory') {
+				$size = $this->scanChildren($path, $recursive, $reuse, $data['fileid'], $lock);
 					$data['size'] = $size;
 				}
-			} catch (NotFoundException $e) {
-				$this->removeFromCache($path);
-				return null;
-			}
 		} finally {
 			if ($lock) {
 				if ($this->storage->instanceOfStorage('\OCP\Files\Storage\ILockingStorage')) {
@@ -347,50 +353,6 @@
 	}
 
 	/**
-	 * Compares $array1 against $array2 and returns all the values in $array1 that are not in $array2
-	 * Note this is a one-way check - i.e. we don't care about things that are in $array2 that aren't in $array1
-	 *
-	 * Supports multi-dimensional arrays
-	 * Also checks keys/indexes
-	 * Comparisons are strict just like array_diff_assoc
-	 * Order of keys/values does not matter
-	 *
-	 * @param array $array1
-	 * @param array $array2
-	 * @return array with the differences between $array1 and $array1
-	 * @throws \InvalidArgumentException if $array1 isn't an actual array
-	 *
-	 */
-	protected function array_diff_assoc_multi(array $array1, array $array2) {
-		
-		$result = [];
-
-		foreach ($array1 as $key => $value) {
-		
-			// if $array2 doesn't have the same key, that's a result
-			if (!array_key_exists($key, $array2)) {
-				$result[$key] = $value;
-				continue;
-			}
-		
-			// if $array2's value for the same key is different, that's a result
-			if ($array2[$key] !== $value && !is_array($value)) {
-				$result[$key] = $value;
-				continue;
-			}
-		
-			if (is_array($value)) {
-				$nestedDiff = $this->array_diff_assoc_multi($value, $array2[$key]);
-				if (!empty($nestedDiff)) {
-					$result[$key] = $nestedDiff;
-					continue;
-				}
-			}
-		}
-		return $result;
-	}
-
-	/**
 	 * Get the children currently in the cache
 	 *
 	 * @param int $folderId
@@ -409,128 +371,90 @@
 	 * scan all the files and folders in a folder
 	 *
 	 * @param string $path
-	 * @param bool|IScanner::SCAN_RECURSIVE_INCOMPLETE $recursive
-	 * @param int $reuse a combination of self::REUSE_*
+	 * @param bool $recursive
+	 * @param int $reuse
 	 * @param int $folderId id for the folder to be scanned
 	 * @param bool $lock set to false to disable getting an additional read lock during scanning
-	 * @param int|float $oldSize the size of the folder before (re)scanning the children
-	 * @return int|float the size of the scanned folder or -1 if the size is unknown at this stage
+	 * @return int the size of the scanned folder or -1 if the size is unknown at this stage
 	 */
-	protected function scanChildren(string $path, $recursive, int $reuse, int $folderId, bool $lock, int|float $oldSize, &$etagChanged = false) {
+	protected function scanChildren($path, $recursive = self::SCAN_RECURSIVE, $reuse = -1, $folderId = null, $lock = true) {
 		if ($reuse === -1) {
 			$reuse = ($recursive === self::SCAN_SHALLOW) ? self::REUSE_ETAG | self::REUSE_SIZE : self::REUSE_ETAG;
 		}
 		$this->emit('\OC\Files\Cache\Scanner', 'scanFolder', [$path, $this->storageId]);
 		$size = 0;
-		$childQueue = $this->handleChildren($path, $recursive, $reuse, $folderId, $lock, $size, $etagChanged);
-
-		foreach ($childQueue as $child => [$childId, $childSize]) {
-			// "etag changed" propagates up, but not down, so we pass `false` to the children even if we already know that the etag of the current folder changed
-			$childEtagChanged = false;
-			$childSize = $this->scanChildren($child, $recursive, $reuse, $childId, $lock, $childSize, $childEtagChanged);
-			$etagChanged |= $childEtagChanged;
+		if (!is_null($folderId)) {
+			$folderId = $this->cache->getId($path);
+		}
+		$childQueue = $this->handleChildren($path, $recursive, $reuse, $folderId, $lock, $size);
 
+		foreach ($childQueue as $child => $childId) {
+			$childSize = $this->scanChildren($child, $recursive, $reuse, $childId, $lock);
 			if ($childSize === -1) {
 				$size = -1;
 			} elseif ($size !== -1) {
 				$size += $childSize;
 			}
 		}
-
-		// for encrypted storages, we trigger a regular folder size calculation instead of using the calculated size
-		// to make sure we also updated the unencrypted-size where applicable
-		if ($this->storage->instanceOfStorage(Encryption::class)) {
-			$this->cache->calculateFolderSize($path);
-		} else {
 			if ($this->cacheActive) {
-				$updatedData = [];
-				if ($oldSize !== $size) {
-					$updatedData['size'] = $size;
-				}
-				if ($etagChanged) {
-					$updatedData['etag'] = uniqid();
-				}
-				if ($updatedData) {
-					$this->cache->update($folderId, $updatedData);
-				}
-			}
+			$this->cache->update($folderId, ['size' => $size]);
 		}
 		$this->emit('\OC\Files\Cache\Scanner', 'postScanFolder', [$path, $this->storageId]);
 		return $size;
 	}
 
-	/**
-	 * @param bool|IScanner::SCAN_RECURSIVE_INCOMPLETE $recursive
-	 */
-	private function handleChildren(string $path, $recursive, int $reuse, int $folderId, bool $lock, int|float &$size, bool &$etagChanged): array {
+	private function handleChildren($path, $recursive, $reuse, $folderId, $lock, &$size) {
 		// we put this in it's own function so it cleans up the memory before we start recursing
 		$existingChildren = $this->getExistingChildren($folderId);
 		$newChildren = iterator_to_array($this->storage->getDirectoryContent($path));
 
-		if (count($existingChildren) === 0 && count($newChildren) === 0) {
-			// no need to do a transaction
-			return [];
-		}
-
 		if ($this->useTransactions) {
-			$this->connection->beginTransaction();
+			\OC::$server->getDatabaseConnection()->beginTransaction();
 		}
 
 		$exceptionOccurred = false;
 		$childQueue = [];
 		$newChildNames = [];
 		foreach ($newChildren as $fileMeta) {
-			$permissions = $fileMeta['scan_permissions'] ?? $fileMeta['permissions'];
+			$permissions = isset($fileMeta['scan_permissions']) ? $fileMeta['scan_permissions'] : $fileMeta['permissions'];
 			if ($permissions === 0) {
 				continue;
 			}
-			$originalFile = $fileMeta['name'];
-			$file = trim(\OC\Files\Filesystem::normalizePath($originalFile), '/');
-			if (trim($originalFile, '/') !== $file) {
-				// encoding mismatch, might require compatibility wrapper
-				\OC::$server->get(LoggerInterface::class)->debug('Scanner: Skipping non-normalized file name "'. $originalFile . '" in path "' . $path . '".', ['app' => 'core']);
-				$this->emit('\OC\Files\Cache\Scanner', 'normalizedNameMismatch', [$path ? $path . '/' . $originalFile : $originalFile]);
-				// skip this entry
-				continue;
-			}
-
+			$file = $fileMeta['name'];
 			$newChildNames[] = $file;
 			$child = $path ? $path . '/' . $file : $file;
 			try {
-				$existingData = $existingChildren[$file] ?? false;
+				$existingData = isset($existingChildren[$file]) ? $existingChildren[$file] : false;
 				$data = $this->scanFile($child, $reuse, $folderId, $existingData, $lock, $fileMeta);
 				if ($data) {
-					if ($data['mimetype'] === 'httpd/unix-directory' && $recursive === self::SCAN_RECURSIVE) {
-						$childQueue[$child] = [$data['fileid'], $data['size']];
-					} elseif ($data['mimetype'] === 'httpd/unix-directory' && $recursive === self::SCAN_RECURSIVE_INCOMPLETE && $data['size'] === -1) {
+					if ($data['mimetype'] === 'httpd/unix-directory' and $recursive === self::SCAN_RECURSIVE) {
+						$childQueue[$child] = $data['fileid'];
+					} elseif ($data['mimetype'] === 'httpd/unix-directory' and $recursive === self::SCAN_RECURSIVE_INCOMPLETE and $data['size'] === -1) {
 						// only recurse into folders which aren't fully scanned
-						$childQueue[$child] = [$data['fileid'], $data['size']];
+						$childQueue[$child] = $data['fileid'];
 					} elseif ($data['size'] === -1) {
 						$size = -1;
 					} elseif ($size !== -1) {
 						$size += $data['size'];
 					}
-
-					if (isset($data['etag_changed']) && $data['etag_changed']) {
-						$etagChanged = true;
-					}
 				}
 			} catch (Exception $ex) {
 				// might happen if inserting duplicate while a scanning
 				// process is running in parallel
 				// log and ignore
 				if ($this->useTransactions) {
-					$this->connection->rollback();
-					$this->connection->beginTransaction();
+					\OC::$server->getDatabaseConnection()->rollback();
+					\OC::$server->getDatabaseConnection()->beginTransaction();
 				}
-				\OC::$server->get(LoggerInterface::class)->debug('Exception while scanning file "' . $child . '"', [
+				\OC::$server->getLogger()->logException($ex, [
+					'message' => 'Exception while scanning file "' . $child . '"',
+					'level' => ILogger::DEBUG,
 					'app' => 'core',
-					'exception' => $ex,
 				]);
 				$exceptionOccurred = true;
 			} catch (\OCP\Lock\LockedException $e) {
 				if ($this->useTransactions) {
-					$this->connection->rollback();
+					\OC::$server->getDatabaseConnection()->rollback();
 				}
 				throw $e;
 			}
@@ -541,7 +465,7 @@
 			$this->removeFromCache($child);
 		}
 		if ($this->useTransactions) {
-			$this->connection->commit();
+			\OC::$server->getDatabaseConnection()->commit();
 		}
 		if ($exceptionOccurred) {
 			// It might happen that the parallel scan process has already
@@ -565,7 +489,7 @@
 		if (pathinfo($file, PATHINFO_EXTENSION) === 'part') {
 			return true;
 		}
-		if (str_contains($file, '.part/')) {
+		if (strpos($file, '.part/') !== false) {
 			return true;
 		}
 
@@ -576,23 +500,12 @@
 	 * walk over any folders that are not fully scanned yet and scan them
 	 */
 	public function backgroundScan() {
-		if ($this->storage->instanceOfStorage(Jail::class)) {
-			// for jail storage wrappers (shares, groupfolders) we run the background scan on the source storage
-			// this is mainly done because the jail wrapper doesn't implement `getIncomplete` (because it would be inefficient).
-			//
-			// Running the scan on the source storage might scan more than "needed", but the unscanned files outside the jail will
-			// have to be scanned at some point anyway.
-			$unJailedScanner = $this->storage->getUnjailedStorage()->getScanner();
-			$unJailedScanner->backgroundScan();
-		} else {
 			if (!$this->cache->inCache('')) {
-				// if the storage isn't in the cache yet, just scan the root completely
 				$this->runBackgroundScanJob(function () {
 					$this->scan('', self::SCAN_RECURSIVE, self::REUSE_ETAG);
 				}, '');
 			} else {
 				$lastPath = null;
-				// find any path marked as unscanned and run the scanner until no more paths are unscanned (or we get stuck)
 				while (($path = $this->cache->getIncomplete()) !== false && $path !== $lastPath) {
 					$this->runBackgroundScanJob(function () use ($path) {
 						$this->scan($path, self::SCAN_RECURSIVE_INCOMPLETE, self::REUSE_ETAG | self::REUSE_SIZE);
@@ -603,9 +516,8 @@
 				}
 			}
 		}
-	}
 
-	protected function runBackgroundScanJob(callable $callback, $path) {
+	private function runBackgroundScanJob(callable $callback, $path) {
 		try {
 			$callback();
 			\OC_Hook::emit('Scanner', 'correctFolderSize', ['path' => $path]);
