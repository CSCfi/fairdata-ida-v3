--- /var/ida/nextcloud-new/lib/private/User/Session.php	2024-11-05 08:30:09.617706934 +0000
+++ /var/ida/nextcloud-old/lib/private/User/Session.php.original	2024-02-20 10:11:39.326443433 +0000
@@ -1,45 +1,71 @@
 <?php
 /**
- * SPDX-FileCopyrightText: 2017 Nextcloud GmbH and Nextcloud contributors
- * SPDX-FileCopyrightText: 2016 ownCloud, Inc.
- * SPDX-License-Identifier: AGPL-3.0-only
+ * @copyright Copyright (c) 2017, Sandro Lutz <sandro.lutz@temparus.ch>
+ * @copyright Copyright (c) 2016, ownCloud, Inc.
+ *
+ * @author Arthur Schiwon <blizzz@arthur-schiwon.de>
+ * @author Bernhard Posselt <dev@bernhard-posselt.com>
+ * @author Bjoern Schiessle <bjoern@schiessle.org>
+ * @author Christoph Wurst <christoph@winzerhof-wurst.at>
+ * @author Felix Rupp <github@felixrupp.com>
+ * @author Greta Doci <gretadoci@gmail.com>
+ * @author Joas Schilling <coding@schilljs.com>
+ * @author Jörn Friedrich Dreyer <jfd@butonic.de>
+ * @author Lionel Elie Mamane <lionel@mamane.lu>
+ * @author Lukas Reschke <lukas@statuscode.ch>
+ * @author Morris Jobke <hey@morrisjobke.de>
+ * @author Robin Appelman <robin@icewind.nl>
+ * @author Robin McCorkell <robin@mccorkell.me.uk>
+ * @author Roeland Jago Douma <roeland@famdouma.nl>
+ * @author Sandro Lutz <sandro.lutz@temparus.ch>
+ * @author Thomas Müller <thomas.mueller@tmit.eu>
+ * @author Vincent Petry <vincent@nextcloud.com>
+ *
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program. If not, see <http://www.gnu.org/licenses/>
+ *
  */
+
 namespace OC\User;
 
 use OC;
+use OC\Authentication\Exceptions\ExpiredTokenException;
+use OC\Authentication\Exceptions\InvalidTokenException;
 use OC\Authentication\Exceptions\PasswordlessTokenException;
 use OC\Authentication\Exceptions\PasswordLoginForbiddenException;
 use OC\Authentication\Token\IProvider;
 use OC\Authentication\Token\IToken;
-use OC\Authentication\Token\PublicKeyToken;
-use OC\Authentication\TwoFactorAuth\Manager as TwoFactorAuthManager;
 use OC\Hooks\Emitter;
 use OC\Hooks\PublicEmitter;
-use OC\Security\CSRF\CsrfTokenManager;
 use OC_User;
 use OC_Util;
 use OCA\DAV\Connector\Sabre\Auth;
-use OCP\AppFramework\Db\TTransactional;
 use OCP\AppFramework\Utility\ITimeFactory;
-use OCP\Authentication\Exceptions\ExpiredTokenException;
-use OCP\Authentication\Exceptions\InvalidTokenException;
-use OCP\EventDispatcher\GenericEvent;
 use OCP\EventDispatcher\IEventDispatcher;
 use OCP\Files\NotPermittedException;
 use OCP\IConfig;
-use OCP\IDBConnection;
+use OCP\ILogger;
 use OCP\IRequest;
 use OCP\ISession;
 use OCP\IUser;
 use OCP\IUserSession;
 use OCP\Lockdown\ILockdownManager;
-use OCP\Security\Bruteforce\IThrottler;
 use OCP\Security\ISecureRandom;
 use OCP\Session\Exceptions\SessionNotAvailableException;
 use OCP\User\Events\PostLoginEvent;
-use OCP\User\Events\UserFirstTimeLoggedInEvent;
 use OCP\Util;
-use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\GenericEvent;
 
 /**
  * Class Session
@@ -64,22 +90,65 @@
  * @package OC\User
  */
 class Session implements IUserSession, Emitter {
-	use TTransactional;
+
+	/** @var Manager|PublicEmitter $manager */
+	private $manager;
+
+	/** @var ISession $session */
+	private $session;
+
+	/** @var ITimeFactory */
+	private $timeFactory;
+
+	/** @var IProvider */
+	private $tokenProvider;
+
+	/** @var IConfig */
+	private $config;
 
 	/** @var User $activeUser */
 	protected $activeUser;
 
-	public function __construct(
-		private Manager          $manager,
-		private ISession         $session,
-		private ITimeFactory     $timeFactory,
-		private ?IProvider       $tokenProvider,
-		private IConfig          $config,
-		private ISecureRandom    $random,
-		private ILockdownManager $lockdownManager,
-		private LoggerInterface  $logger,
-		private IEventDispatcher $dispatcher,
+	/** @var ISecureRandom */
+	private $random;
+
+	/** @var ILockdownManager  */
+	private $lockdownManager;
+
+	/** @var ILogger */
+	private $logger;
+	/** @var IEventDispatcher */
+	private $dispatcher;
+
+	/**
+	 * @param Manager $manager
+	 * @param ISession $session
+	 * @param ITimeFactory $timeFactory
+	 * @param IProvider $tokenProvider
+	 * @param IConfig $config
+	 * @param ISecureRandom $random
+	 * @param ILockdownManager $lockdownManager
+	 * @param ILogger $logger
+	 */
+	public function __construct(Manager $manager,
+								ISession $session,
+								ITimeFactory $timeFactory,
+								$tokenProvider,
+								IConfig $config,
+								ISecureRandom $random,
+								ILockdownManager $lockdownManager,
+								ILogger $logger,
+								IEventDispatcher $dispatcher
 	) {
+		$this->manager = $manager;
+		$this->session = $session;
+		$this->timeFactory = $timeFactory;
+		$this->tokenProvider = $tokenProvider;
+		$this->config = $config;
+		$this->random = $random;
+		$this->lockdownManager = $lockdownManager;
+		$this->logger = $logger;
+		$this->dispatcher = $dispatcher;
 	}
 
 	/**
@@ -103,7 +172,7 @@
 	 * @param string $method optional
 	 * @param callable $callback optional
 	 */
-	public function removeListener($scope = null, $method = null, ?callable $callback = null) {
+	public function removeListener($scope = null, $method = null, callable $callback = null) {
 		$this->manager->removeListener($scope, $method, $callback);
 	}
 
@@ -153,15 +222,6 @@
 	}
 
 	/**
-	 * Temporarily set the currently active user without persisting in the session
-	 *
-	 * @param IUser|null $user
-	 */
-	public function setVolatileActiveUser(?IUser $user): void {
-		$this->activeUser = $user;
-	}
-
-	/**
 	 * get the current active user
 	 *
 	 * @return IUser|null Current user, otherwise null
@@ -240,9 +300,9 @@
 	}
 
 	/**
-	 * Get the login name of the current user
+	 * get the login name of the current user
 	 *
-	 * @return ?string
+	 * @return string
 	 */
 	public function getLoginName() {
 		if ($this->activeUser) {
@@ -318,13 +378,12 @@
 		if (!$user->isEnabled()) {
 			// disabled users can not log in
 			// injecting l10n does not work - there is a circular dependency between session and \OCP\L10N\IFactory
-			$message = \OCP\Util::getL10N('lib')->t('Account disabled');
+			$message = \OC::$server->getL10N('lib')->t('User disabled');
 			throw new LoginException($message);
 		}
 
 		if ($regenerateSessionId) {
 			$this->session->regenerateId();
-			$this->session->remove(Auth::DAV_AUTHENTICATED);
 		}
 
 		$this->setUser($user);
@@ -357,7 +416,7 @@
 			return true;
 		}
 
-		$message = \OCP\Util::getL10N('lib')->t('Login canceled by app');
+		$message = \OC::$server->getL10N('lib')->t('Login canceled by app');
 		throw new LoginException($message);
 	}
 
@@ -370,7 +429,7 @@
 	 * @param string $user
 	 * @param string $password
 	 * @param IRequest $request
-	 * @param IThrottler $throttler
+	 * @param OC\Security\Bruteforce\Throttler $throttler
 	 * @throws LoginException
 	 * @throws PasswordLoginForbiddenException
 	 * @return boolean
@@ -378,9 +437,8 @@
 	public function logClientIn($user,
 		$password,
 		IRequest $request,
-		IThrottler $throttler) {
-		$remoteAddress = $request->getRemoteAddress();
-		$currentDelay = $throttler->sleepDelayOrThrowOnMax($remoteAddress, 'login');
+								OC\Security\Bruteforce\Throttler $throttler) {
+		$currentDelay = $throttler->sleepDelay($request->getRemoteAddress(), 'login');
 
 		if ($this->manager instanceof PublicEmitter) {
 			$this->manager->emit('\OC\User', 'preLogin', [$user, $password]);
@@ -402,24 +460,19 @@
 
 		// Try to login with this username and password
 		if (!$this->login($user, $password)) {
-			// Failed, maybe the user used their email address
-			if (!filter_var($user, FILTER_VALIDATE_EMAIL)) {
-				$this->handleLoginFailed($throttler, $currentDelay, $remoteAddress, $user, $password);
-				return false;
-			}
 
-			if ($isTokenPassword) {
-				$dbToken = $this->tokenProvider->getToken($password);
-				$userFromToken = $this->manager->get($dbToken->getUID());
-				$isValidEmailLogin = $userFromToken->getEMailAddress() === $user
-					&& $this->validateTokenLoginName($userFromToken->getEMailAddress(), $dbToken);
-			} else {
+			// Failed, maybe the user used their email address
 				$users = $this->manager->getByEmail($user);
-				$isValidEmailLogin = (\count($users) === 1 && $this->login($users[0]->getUID(), $password));
-			}
+			if (!(\count($users) === 1 && $this->login($users[0]->getUID(), $password))) {
+				$this->logger->warning('Login failed: \'' . $user . '\' (Remote IP: \'' . \OC::$server->getRequest()->getRemoteAddress() . '\')', ['app' => 'core']);
+
+				$throttler->registerAttempt('login', $request->getRemoteAddress(), ['user' => $user]);
 
-			if (!$isValidEmailLogin) {
-				$this->handleLoginFailed($throttler, $currentDelay, $remoteAddress, $user, $password);
+				$this->dispatcher->dispatchTyped(new OC\Authentication\Events\LoginFailed($user));
+
+				if ($currentDelay === 0) {
+					$throttler->sleepDelay($request->getRemoteAddress(), 'login');
+				}
 				return false;
 			}
 		}
@@ -434,17 +487,6 @@
 		return true;
 	}
 
-	private function handleLoginFailed(IThrottler $throttler, int $currentDelay, string $remoteAddress, string $user, ?string $password) {
-		$this->logger->warning("Login failed: '" . $user . "' (Remote IP: '" . $remoteAddress . "')", ['app' => 'core']);
-
-		$throttler->registerAttempt('login', $remoteAddress, ['user' => $user]);
-		$this->dispatcher->dispatchTyped(new OC\Authentication\Events\LoginFailed($user, $password));
-
-		if ($currentDelay === 0) {
-			$throttler->sleepDelayOrThrowOnMax($remoteAddress, 'login');
-		}
-	}
-
 	protected function supportsCookies(IRequest $request) {
 		if (!is_null($request->getCookie('cookie_test'))) {
 			return true;
@@ -453,8 +495,8 @@
 		return false;
 	}
 
-	private function isTokenAuthEnforced(): bool {
-		return $this->config->getSystemValueBool('token_auth_enforced', false);
+	private function isTokenAuthEnforced() {
+		return $this->config->getSystemValue('token_auth_enforced', false);
 	}
 
 	protected function isTwoFactorEnforced($username) {
@@ -475,7 +517,7 @@
 			$user = $users[0];
 		}
 		// DI not possible due to cyclic dependencies :'-/
-		return OC::$server->get(TwoFactorAuthManager::class)->isTwoFactorAuthenticated($user);
+		return OC::$server->getTwoFactorAuthManager()->isTwoFactorAuthenticated($user);
 	}
 
 	/**
@@ -492,8 +534,9 @@
 		} catch (ExpiredTokenException $e) {
 			throw $e;
 		} catch (InvalidTokenException $ex) {
-			$this->logger->debug('Token is not valid: ' . $ex->getMessage(), [
-				'exception' => $ex,
+			$this->logger->logException($ex, [
+				'level' => ILogger::DEBUG,
+				'message' => 'Token is not valid: ' . $ex->getMessage(),
 			]);
 			return false;
 		}
@@ -503,14 +546,14 @@
 		if ($refreshCsrfToken) {
 			// TODO: mock/inject/use non-static
 			// Refresh the token
-			\OC::$server->get(CsrfTokenManager::class)->refreshToken();
+			\OC::$server->getCsrfTokenManager()->refreshToken();
 		}
 
-		if ($firstTimeLogin) {
 			//we need to pass the user name, which may differ from login name
 			$user = $this->getUser()->getUID();
 			OC_Util::setupFS($user);
 
+		if ($firstTimeLogin) {
 			// TODO: lock necessary?
 			//trigger creation of user home and /files folder
 			$userFolder = \OC::$server->getUserFolder($user);
@@ -523,8 +566,7 @@
 			}
 
 			// trigger any other initialization
-			\OC::$server->get(IEventDispatcher::class)->dispatch(IUser::class . '::firstLogin', new GenericEvent($this->getUser()));
-			\OC::$server->get(IEventDispatcher::class)->dispatchTyped(new UserFirstTimeLoggedInEvent($this->getUser()));
+			\OC::$server->getEventDispatcher()->dispatch(IUser::class . '::firstLogin', new GenericEvent($this->getUser()));
 		}
 	}
 
@@ -533,11 +575,11 @@
 	 *
 	 * @todo do not allow basic auth if the user is 2FA enforced
 	 * @param IRequest $request
-	 * @param IThrottler $throttler
+	 * @param OC\Security\Bruteforce\Throttler $throttler
 	 * @return boolean if the login was successful
 	 */
 	public function tryBasicAuthLogin(IRequest $request,
-		IThrottler $throttler) {
+									  OC\Security\Bruteforce\Throttler $throttler) {
 		if (!empty($request->server['PHP_AUTH_USER']) && !empty($request->server['PHP_AUTH_PW'])) {
 			try {
 				if ($this->logClientIn($request->server['PHP_AUTH_USER'], $request->server['PHP_AUTH_PW'], $request, $throttler)) {
@@ -557,8 +599,6 @@
 
 					return true;
 				}
-				// If credentials were provided, they need to be valid, otherwise we do boom
-				throw new LoginException();
 			} catch (PasswordLoginForbiddenException $ex) {
 				// Nothing to do
 			}
@@ -607,7 +647,7 @@
 			// Ignore and use empty string instead
 		}
 
-		$this->manager->emit('\OC\User', 'preLogin', [$dbToken->getLoginName(), $password]);
+		$this->manager->emit('\OC\User', 'preLogin', [$uid, $password]);
 
 		$user = $this->manager->get($uid);
 		if (is_null($user)) {
@@ -640,15 +680,13 @@
 			// User does not exist
 			return false;
 		}
-		$name = isset($request->server['HTTP_USER_AGENT']) ? mb_convert_encoding($request->server['HTTP_USER_AGENT'], 'UTF-8', 'ISO-8859-1') : 'unknown browser';
+		$name = isset($request->server['HTTP_USER_AGENT']) ? $request->server['HTTP_USER_AGENT'] : 'unknown browser';
 		try {
 			$sessionId = $this->session->getId();
 			$pwd = $this->getPassword($password);
 			// Make sure the current sessionId has no leftover tokens
-			$this->atomic(function () use ($sessionId, $uid, $loginName, $pwd, $name, $remember) {
 				$this->tokenProvider->invalidateToken($sessionId);
 				$this->tokenProvider->generateToken($sessionId, $uid, $loginName, $pwd, $name, IToken::TEMPORARY_TOKEN, $remember);
-			}, \OCP\Server::get(IDBConnection::class));
 			return true;
 		} catch (SessionNotAvailableException $ex) {
 			// This can happen with OCC, where a memory session is used
@@ -710,6 +748,7 @@
 				return false;
 			}
 
+			$dbToken->setLastCheck($now);
 			return true;
 		}
 
@@ -727,10 +766,6 @@
 		}
 
 		$dbToken->setLastCheck($now);
-		if ($dbToken instanceof PublicKeyToken) {
-			$dbToken->setLastActivity($now);
-		}
-		$this->tokenProvider->updateToken($dbToken);
 		return true;
 	}
 
@@ -747,23 +782,23 @@
 		try {
 			$dbToken = $this->tokenProvider->getToken($token);
 		} catch (InvalidTokenException $ex) {
-			$this->logger->debug('Session token is invalid because it does not exist', [
-				'app' => 'core',
-				'user' => $user,
-				'exception' => $ex,
-			]);
 			return false;
 		}
 
-		if (!is_null($user) && !$this->validateTokenLoginName($user, $dbToken)) {
+		// Check if login names match
+		if (!is_null($user) && $dbToken->getLoginName() !== $user) {
+			// TODO: this makes it impossible to use different login names on browser and client
+			// e.g. login by e-mail 'user@example.com' on browser for generating the token will not
+			//      allow to use the client token with the login name 'user'.
+			$this->logger->error('App token login name does not match', [
+				'tokenLoginName' => $dbToken->getLoginName(),
+				'sessionLoginName' => $user,
+			]);
+
 			return false;
 		}
 
 		if (!$this->checkTokenCredentials($dbToken, $token)) {
-			$this->logger->warning('Session token credentials are invalid', [
-				'app' => 'core',
-				'user' => $user,
-			]);
 			return false;
 		}
 
@@ -776,27 +811,6 @@
 	}
 
 	/**
-	 * Check if login names match
-	 */
-	private function validateTokenLoginName(?string $loginName, IToken $token): bool {
-		if ($token->getLoginName() !== $loginName) {
-			// TODO: this makes it impossible to use different login names on browser and client
-			// e.g. login by e-mail 'user@example.com' on browser for generating the token will not
-			//      allow to use the client token with the login name 'user'.
-			$this->logger->error('App token login name does not match', [
-				'tokenLoginName' => $token->getLoginName(),
-				'sessionLoginName' => $loginName,
-				'app' => 'core',
-				'user' => $token->getUID(),
-			]);
-
-			return false;
-		}
-
-		return true;
-	}
-
-	/**
 	 * Tries to login the user with auth token header
 	 *
 	 * @param IRequest $request
@@ -805,18 +819,15 @@
 	 */
 	public function tryTokenLogin(IRequest $request) {
 		$authHeader = $request->getHeader('Authorization');
-		if (str_starts_with($authHeader, 'Bearer ')) {
+		if (strpos($authHeader, 'Bearer ') === 0) {
 			$token = substr($authHeader, 7);
-		} elseif ($request->getCookie($this->config->getSystemValueString('instanceid')) !== null) {
-			// No auth header, let's try session id, but only if this is an existing
-			// session and the request has a session cookie
+		} else {
+			// No auth header, let's try session id
 			try {
 				$token = $this->session->getId();
 			} catch (SessionNotAvailableException $ex) {
 				return false;
 			}
-		} else {
-			return false;
 		}
 
 		if (!$this->loginWithToken($token)) {
@@ -863,41 +874,20 @@
 		$tokens = $this->config->getUserKeys($uid, 'login_token');
 		// test cookies token against stored tokens
 		if (!in_array($currentToken, $tokens, true)) {
-			$this->logger->info('Tried to log in but could not verify token', [
-				'app' => 'core',
-				'user' => $uid,
-			]);
 			return false;
 		}
 		// replace successfully used token with a new one
 		$this->config->deleteUserValue($uid, 'login_token', $currentToken);
 		$newToken = $this->random->generate(32);
-		$this->config->setUserValue($uid, 'login_token', $newToken, (string)$this->timeFactory->getTime());
-		$this->logger->debug('Remember-me token replaced', [
-			'app' => 'core',
-			'user' => $uid,
-		]);
+		$this->config->setUserValue($uid, 'login_token', $newToken, $this->timeFactory->getTime());
 
 		try {
 			$sessionId = $this->session->getId();
 			$token = $this->tokenProvider->renewSessionToken($oldSessionId, $sessionId);
-			$this->logger->debug('Session token replaced', [
-				'app' => 'core',
-				'user' => $uid,
-			]);
 		} catch (SessionNotAvailableException $ex) {
-			$this->logger->critical('Could not renew session token for {uid} because the session is unavailable', [
-				'app' => 'core',
-				'uid' => $uid,
-				'user' => $uid,
-			]);
 			return false;
 		} catch (InvalidTokenException $ex) {
-			$this->logger->error('Renewing session token failed: ' . $ex->getMessage(), [
-				'app' => 'core',
-				'user' => $uid,
-				'exception' => $ex,
-			]);
+			\OC::$server->getLogger()->warning('Renewing session token failed', ['app' => 'core']);
 			return false;
 		}
 
@@ -924,7 +914,7 @@
 	 */
 	public function createRememberMeToken(IUser $user) {
 		$token = $this->random->generate(32);
-		$this->config->setUserValue($user->getUID(), 'login_token', $token, (string)$this->timeFactory->getTime());
+		$this->config->setUserValue($user->getUID(), 'login_token', $token, $this->timeFactory->getTime());
 		$this->setMagicInCookie($user->getUID(), $token);
 	}
 
@@ -936,17 +926,10 @@
 		$this->manager->emit('\OC\User', 'logout', [$user]);
 		if ($user !== null) {
 			try {
-				$token = $this->session->getId();
-				$this->tokenProvider->invalidateToken($token);
-				$this->logger->debug('Session token invalidated before logout', [
-					'user' => $user->getUID(),
-				]);
+				$this->tokenProvider->invalidateToken($this->session->getId());
 			} catch (SessionNotAvailableException $ex) {
 			}
 		}
-		$this->logger->debug('Logging out', [
-			'user' => $user === null ? null : $user->getUID(),
-		]);
 		$this->setUser(null);
 		$this->setLoginName(null);
 		$this->setToken(null);
@@ -968,7 +951,7 @@
 			$webRoot = '/';
 		}
 
-		$maxAge = $this->config->getSystemValueInt('remember_login_cookie_lifetime', 60 * 60 * 24 * 15);
+		$maxAge = $this->config->getSystemValue('remember_login_cookie_lifetime', 60 * 60 * 24 * 15);
 		\OC\Http\CookieHelper::setCookie(
 			'nc_username',
 			$username,
