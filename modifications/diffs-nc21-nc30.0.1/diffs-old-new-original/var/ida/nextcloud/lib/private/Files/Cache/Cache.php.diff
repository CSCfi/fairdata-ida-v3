--- /var/ida/nextcloud-new/lib/private/Files/Cache/Cache.php	2024-11-05 08:30:09.645707031 +0000
+++ /var/ida/nextcloud-old/lib/private/Files/Cache/Cache.php.original	2024-02-20 10:11:39.285443294 +0000
@@ -1,47 +1,69 @@
 <?php
-
 /**
- * SPDX-FileCopyrightText: 2016-2024 Nextcloud GmbH and Nextcloud contributors
- * SPDX-FileCopyrightText: 2016 ownCloud, Inc.
- * SPDX-License-Identifier: AGPL-3.0-only
+ * @copyright Copyright (c) 2016, ownCloud, Inc.
+ *
+ * @author Andreas Fischer <bantu@owncloud.com>
+ * @author Ari Selseng <ari@selseng.net>
+ * @author Artem Kochnev <MrJeos@gmail.com>
+ * @author Björn Schießle <bjoern@schiessle.org>
+ * @author Christoph Wurst <christoph@winzerhof-wurst.at>
+ * @author Daniel Kesselberg <mail@danielkesselberg.de>
+ * @author Florin Peter <github@florin-peter.de>
+ * @author Frédéric Fortier <frederic.fortier@oronospolytechnique.com>
+ * @author Jens-Christian Fischer <jens-christian.fischer@switch.ch>
+ * @author Joas Schilling <coding@schilljs.com>
+ * @author Jörn Friedrich Dreyer <jfd@butonic.de>
+ * @author Lukas Reschke <lukas@statuscode.ch>
+ * @author Michael Gapczynski <GapczynskiM@gmail.com>
+ * @author Morris Jobke <hey@morrisjobke.de>
+ * @author Robin Appelman <robin@icewind.nl>
+ * @author Robin McCorkell <robin@mccorkell.me.uk>
+ * @author Roeland Jago Douma <roeland@famdouma.nl>
+ * @author Vincent Petry <vincent@nextcloud.com>
+ *
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program. If not, see <http://www.gnu.org/licenses/>
+ *
  */
+
 namespace OC\Files\Cache;
 
 use Doctrine\DBAL\Exception\UniqueConstraintViolationException;
-use OC\DB\Exceptions\DbalException;
-use OC\DB\QueryBuilder\Sharded\ShardDefinition;
-use OC\Files\Search\SearchComparison;
-use OC\Files\Search\SearchQuery;
-use OC\Files\Storage\Wrapper\Encryption;
-use OC\SystemConfig;
+use OCP\DB\IResult;
 use OCP\DB\QueryBuilder\IQueryBuilder;
 use OCP\EventDispatcher\IEventDispatcher;
 use OCP\Files\Cache\CacheEntryInsertedEvent;
-use OCP\Files\Cache\CacheEntryRemovedEvent;
 use OCP\Files\Cache\CacheEntryUpdatedEvent;
 use OCP\Files\Cache\CacheInsertEvent;
+use OCP\Files\Cache\CacheEntryRemovedEvent;
 use OCP\Files\Cache\CacheUpdateEvent;
 use OCP\Files\Cache\ICache;
 use OCP\Files\Cache\ICacheEntry;
 use OCP\Files\FileInfo;
 use OCP\Files\IMimeTypeLoader;
-use OCP\Files\Search\ISearchComparison;
-use OCP\Files\Search\ISearchOperator;
 use OCP\Files\Search\ISearchQuery;
 use OCP\Files\Storage\IStorage;
-use OCP\FilesMetadata\IFilesMetadataManager;
 use OCP\IDBConnection;
-use OCP\Util;
-use Psr\Log\LoggerInterface;
 
 /**
  * Metadata cache for a storage
  *
- * The cache stores the metadata for all files and folders in a storage and is kept up to date through the following mechanisms:
+ * The cache stores the metadata for all files and folders in a storage and is kept up to date trough the following mechanisms:
  *
  * - Scanner: scans the storage and updates the cache where needed
- * - Watcher: checks for changes made to the filesystem outside of the Nextcloud instance and rescans files and folder when a change is detected
- * - Updater: listens to changes made to the filesystem inside of the Nextcloud instance and updates the cache where needed
+ * - Watcher: checks for changes made to the filesystem outside of the ownCloud instance and rescans files and folder when a change is detected
+ * - Updater: listens to changes made to the filesystem inside of the ownCloud instance and updates the cache where needed
  * - ChangePropagator: updates the mtime and etags of parent folders whenever a change to the cache is made to the cache by the updater
  */
 class Cache implements ICache {
@@ -52,51 +74,62 @@
 	/**
 	 * @var array partial data for the cache
 	 */
-	protected array $partial = [];
-	protected string $storageId;
-	protected Storage $storageCache;
-	protected IMimeTypeLoader$mimetypeLoader;
-	protected IDBConnection $connection;
-	protected SystemConfig $systemConfig;
-	protected LoggerInterface $logger;
-	protected QuerySearchHelper $querySearchHelper;
-	protected IEventDispatcher $eventDispatcher;
-	protected IFilesMetadataManager $metadataManager;
-
-	public function __construct(
-		private IStorage $storage,
-		// this constructor is used in to many pleases to easily do proper di
-		// so instead we group it all together
-		?CacheDependencies $dependencies = null,
-	) {
+	protected $partial = [];
+
+	/**
+	 * @var string
+	 */
+	protected $storageId;
+
+	private $storage;
+
+	/**
+	 * @var Storage $storageCache
+	 */
+	protected $storageCache;
+
+	/** @var IMimeTypeLoader */
+	protected $mimetypeLoader;
+
+	/**
+	 * @var IDBConnection
+	 */
+	protected $connection;
+
+	/**
+	 * @var IEventDispatcher
+	 */
+	protected $eventDispatcher;
+
+	/** @var QuerySearchHelper */
+	protected $querySearchHelper;
+
+	/**
+	 * @param IStorage $storage
+	 */
+	public function __construct(IStorage $storage) {
 		$this->storageId = $storage->getId();
+		$this->storage = $storage;
 		if (strlen($this->storageId) > 64) {
 			$this->storageId = md5($this->storageId);
 		}
-		if (!$dependencies) {
-			$dependencies = \OC::$server->get(CacheDependencies::class);
-		}
-		$this->storageCache = new Storage($this->storage, true, $dependencies->getConnection());
-		$this->mimetypeLoader = $dependencies->getMimeTypeLoader();
-		$this->connection = $dependencies->getConnection();
-		$this->systemConfig = $dependencies->getSystemConfig();
-		$this->logger = $dependencies->getLogger();
-		$this->querySearchHelper = $dependencies->getQuerySearchHelper();
-		$this->eventDispatcher = $dependencies->getEventDispatcher();
-		$this->metadataManager = $dependencies->getMetadataManager();
+
+		$this->storageCache = new Storage($storage);
+		$this->mimetypeLoader = \OC::$server->getMimeTypeLoader();
+		$this->connection = \OC::$server->getDatabaseConnection();
+		$this->eventDispatcher = \OC::$server->get(IEventDispatcher::class);
+		$this->querySearchHelper = new QuerySearchHelper($this->mimetypeLoader);
 	}
 
 	protected function getQueryBuilder() {
 		return new CacheQueryBuilder(
-			$this->connection->getQueryBuilder(),
-			$this->metadataManager,
+			$this->connection,
+			\OC::$server->getSystemConfig(),
+			\OC::$server->getLogger(),
+			$this
 		);
 	}
 
-	public function getStorageCache(): Storage {
-		return $this->storageCache;
-	}
-
 	/**
 	 * Get the numeric storage id for this cache's storage
 	 *
@@ -110,34 +143,32 @@
 	 * get the stored metadata of a file or folder
 	 *
 	 * @param string | int $file either the path of a file or folder or the file id for a file or folder
-	 * @return ICacheEntry|false the cache entry as array or false if the file is not found in the cache
+	 * @return ICacheEntry|false the cache entry as array of false if the file is not found in the cache
 	 */
 	public function get($file) {
 		$query = $this->getQueryBuilder();
 		$query->selectFileCache();
-		$metadataQuery = $query->selectMetadata();
 
-		if (is_string($file) || $file == '') {
+		if (is_string($file) or $file == '') {
 			// normalize file
 			$file = $this->normalize($file);
 
-			$query->wherePath($file);
+			$query->whereStorageId()
+				->wherePath($file);
 		} else { //file id
 			$query->whereFileId($file);
 		}
-		$query->whereStorageId($this->getNumericStorageId());
 
 		$result = $query->execute();
 		$data = $result->fetch();
 		$result->closeCursor();
 
 		//merge partial data
-		if (!$data && is_string($file) && isset($this->partial[$file])) {
+		if (!$data and is_string($file) and isset($this->partial[$file])) {
 			return $this->partial[$file];
 		} elseif (!$data) {
 			return $data;
 		} else {
-			$data['metadata'] = $metadataQuery->extractMetadata($data)->asArray();
 			return self::cacheEntryFromData($data, $this->mimetypeLoader);
 		}
 	}
@@ -151,12 +182,9 @@
 	 */
 	public static function cacheEntryFromData($data, IMimeTypeLoader $mimetypeLoader) {
 		//fix types
-		$data['name'] = (string)$data['name'];
-		$data['path'] = (string)$data['path'];
 		$data['fileid'] = (int)$data['fileid'];
 		$data['parent'] = (int)$data['parent'];
-		$data['size'] = Util::numericToNumber($data['size']);
-		$data['unencrypted_size'] = Util::numericToNumber($data['unencrypted_size'] ?? 0);
+		$data['size'] = 0 + $data['size'];
 		$data['mtime'] = (int)$data['mtime'];
 		$data['storage_mtime'] = (int)$data['storage_mtime'];
 		$data['encryptedVersion'] = (int)$data['encrypted'];
@@ -200,17 +228,13 @@
 			$query = $this->getQueryBuilder();
 			$query->selectFileCache()
 				->whereParent($fileId)
-				->whereStorageId($this->getNumericStorageId())
 				->orderBy('name', 'ASC');
 
-			$metadataQuery = $query->selectMetadata();
-
 			$result = $query->execute();
 			$files = $result->fetchAll();
 			$result->closeCursor();
 
-			return array_map(function (array $data) use ($metadataQuery) {
-				$data['metadata'] = $metadataQuery->extractMetadata($data)->asArray();
+			return array_map(function (array $data) {
 				return self::cacheEntryFromData($data, $this->mimetypeLoader);
 			}, $files);
 		}
@@ -265,9 +289,6 @@
 		if (!isset($data['parent'])) {
 			$data['parent'] = $this->getParentId($file);
 		}
-		if ($data['parent'] === -1 && $file !== '') {
-			throw new \Exception('Parent folder not in filecache for ' . $file);
-		}
 		$data['name'] = basename($file);
 
 		[$values, $extensionValues] = $this->normalizeData($data);
@@ -288,7 +309,6 @@
 				if (count($extensionValues)) {
 					$query = $this->getQueryBuilder();
 					$query->insert('filecache_extended');
-					$query->hintShardKey('storage', $storageId);
 
 					$query->setValue('fileid', $query->createNamedParameter($fileId, IQueryBuilder::PARAM_INT));
 					foreach ($extensionValues as $column => $value) {
@@ -301,7 +321,6 @@
 				$this->eventDispatcher->dispatch(CacheInsertEvent::class, $event);
 				$this->eventDispatcher->dispatchTyped($event);
 				return $fileId;
-			}
 		} catch (UniqueConstraintViolationException $e) {
 			// entry exists already
 			if ($this->connection->inTransaction()) {
@@ -318,6 +337,7 @@
 			throw new \RuntimeException('File entry could not be inserted but could also not be selected with getId() in order to perform an update. Please try again.');
 		}
 	}
+	}
 
 	/**
 	 * update the metadata of an existing file or folder in the cache
@@ -343,7 +363,6 @@
 
 			$query->update('filecache')
 				->whereFileId($id)
-				->whereStorageId($this->getNumericStorageId())
 				->andWhere($query->expr()->orX(...array_map(function ($key, $value) use ($query) {
 					return $query->expr()->orX(
 						$query->expr()->neq($key, $query->createNamedParameter($value)),
@@ -359,10 +378,10 @@
 		}
 
 		if (count($extensionValues)) {
+
 			try {
 				$query = $this->getQueryBuilder();
 				$query->insert('filecache_extended');
-				$query->hintShardKey('storage', $this->getNumericStorageId());
 
 				$query->setValue('fileid', $query->createNamedParameter($id, IQueryBuilder::PARAM_INT));
 				foreach ($extensionValues as $column => $value) {
@@ -374,7 +393,6 @@
 				$query = $this->getQueryBuilder();
 				$query->update('filecache_extended')
 					->whereFileId($id)
-					->hintShardKey('storage', $this->getNumericStorageId())
 					->andWhere($query->expr()->orX(...array_map(function ($key, $value) use ($query) {
 						return $query->expr()->orX(
 							$query->expr()->neq($key, $query->createNamedParameter($value)),
@@ -408,7 +426,7 @@
 	protected function normalizeData(array $data): array {
 		$fields = [
 			'path', 'parent', 'name', 'mimetype', 'size', 'mtime', 'storage_mtime', 'encrypted',
-			'etag', 'permissions', 'checksum', 'storage', 'unencrypted_size'];
+			'etag', 'permissions', 'checksum', 'storage'];
 		$extensionFields = ['metadata_etag', 'creation_time', 'upload_time'];
 
 		$doNotCopyStorageMTime = false;
@@ -421,7 +439,7 @@
 		$params = [];
 		$extensionParams = [];
 		foreach ($data as $name => $value) {
-			if (in_array($name, $fields)) {
+			if (array_search($name, $fields) !== false) {
 				if ($name === 'path') {
 					$params['path_hash'] = md5($value);
 				} elseif ($name === 'mimetype') {
@@ -441,7 +459,7 @@
 				}
 				$params[$name] = $value;
 			}
-			if (in_array($name, $extensionFields)) {
+			if (array_search($name, $extensionFields) !== false) {
 				$extensionParams[$name] = $value;
 			}
 		}
@@ -465,7 +483,7 @@
 		$query = $this->getQueryBuilder();
 		$query->select('fileid')
 			->from('filecache')
-			->whereStorageId($this->getNumericStorageId())
+			->whereStorageId()
 			->wherePath($file);
 
 		$result = $query->execute();
@@ -518,17 +536,15 @@
 	public function remove($file) {
 		$entry = $this->get($file);
 
-		if ($entry instanceof ICacheEntry) {
+		if ($entry) {
 			$query = $this->getQueryBuilder();
 			$query->delete('filecache')
-				->whereStorageId($this->getNumericStorageId())
 				->whereFileId($entry->getId());
 			$query->execute();
 
 			$query = $this->getQueryBuilder();
 			$query->delete('filecache_extended')
-				->whereFileId($entry->getId())
-				->hintShardKey('storage', $this->getNumericStorageId());
+				->whereFileId($entry->getId());
 			$query->execute();
 
 			if ($entry->getMimeType() == FileInfo::MIMETYPE_FOLDER) {
@@ -540,7 +556,20 @@
 	}
 
 	/**
-	 * Remove all children of a folder
+	 * Get all sub folders of a folder
+	 *
+	 * @param ICacheEntry $entry the cache entry of the folder to get the subfolders for
+	 * @return ICacheEntry[] the cache entries for the subfolders
+	 */
+	private function getSubFolders(ICacheEntry $entry) {
+		$children = $this->getFolderContentsById($entry->getId());
+		return array_filter($children, function ($child) {
+			return $child->getMimeType() == FileInfo::MIMETYPE_FOLDER;
+		});
+	}
+
+	/**
+	 * Recursively remove all children of a folder
 	 *
 	 * @param ICacheEntry $entry the cache entry of the folder to remove the children of
 	 * @throws \OC\DatabaseException
@@ -548,45 +577,24 @@
 	private function removeChildren(ICacheEntry $entry) {
 		$parentIds = [$entry->getId()];
 		$queue = [$entry->getId()];
-		$deletedIds = [];
-		$deletedPaths = [];
 
-		// we walk depth first through the file tree, removing all filecache_extended attributes while we walk
+		// we walk depth first trough the file tree, removing all filecache_extended attributes while we walk
 		// and collecting all folder ids to later use to delete the filecache entries
 		while ($entryId = array_pop($queue)) {
 			$children = $this->getFolderContentsById($entryId);
 			$childIds = array_map(function (ICacheEntry $cacheEntry) {
 				return $cacheEntry->getId();
 			}, $children);
-			$childPaths = array_map(function (ICacheEntry $cacheEntry) {
-				return $cacheEntry->getPath();
-			}, $children);
-
-			foreach ($childIds as $childId) {
-				$deletedIds[] = $childId;
-			}
-
-			foreach ($childPaths as $childPath) {
-				$deletedPaths[] = $childPath;
-			}
 
 			$query = $this->getQueryBuilder();
 			$query->delete('filecache_extended')
-				->where($query->expr()->in('fileid', $query->createParameter('childIds')))
-				->hintShardKey('storage', $this->getNumericStorageId());
-
-			foreach (array_chunk($childIds, 1000) as $childIdChunk) {
-				$query->setParameter('childIds', $childIdChunk, IQueryBuilder::PARAM_INT_ARRAY);
+				->where($query->expr()->in('fileid', $query->createNamedParameter($childIds, IQueryBuilder::PARAM_INT_ARRAY)));
 				$query->execute();
-			}
 
 			/** @var ICacheEntry[] $childFolders */
-			$childFolders = [];
-			foreach ($children as $child) {
-				if ($child->getMimeType() == FileInfo::MIMETYPE_FOLDER) {
-					$childFolders[] = $child;
-				}
-			}
+			$childFolders = array_filter($children, function ($child) {
+				return $child->getMimeType() == FileInfo::MIMETYPE_FOLDER;
+			});
 			foreach ($childFolders as $folder) {
 				$parentIds[] = $folder->getId();
 				$queue[] = $folder->getId();
@@ -595,28 +603,10 @@
 
 		$query = $this->getQueryBuilder();
 		$query->delete('filecache')
-			->whereStorageId($this->getNumericStorageId())
-			->whereParentInParameter('parentIds');
-
-		// Sorting before chunking allows the db to find the entries close to each
-		// other in the index
-		sort($parentIds, SORT_NUMERIC);
-		foreach (array_chunk($parentIds, 1000) as $parentIdChunk) {
-			$query->setParameter('parentIds', $parentIdChunk, IQueryBuilder::PARAM_INT_ARRAY);
+			->whereParentIn($parentIds);
 			$query->execute();
 		}
 
-		foreach (array_combine($deletedIds, $deletedPaths) as $fileId => $filePath) {
-			$cacheEntryRemovedEvent = new CacheEntryRemovedEvent(
-				$this->storage,
-				$filePath,
-				$fileId,
-				$this->getNumericStorageId()
-			);
-			$this->eventDispatcher->dispatchTyped($cacheEntryRemovedEvent);
-		}
-	}
-
 	/**
 	 * Move a file or folder in the cache
 	 *
@@ -637,10 +627,6 @@
 		return [$this->getNumericStorageId(), $path];
 	}
 
-	protected function hasEncryptionWrapper(): bool {
-		return $this->storage->instanceOfStorage(Encryption::class);
-	}
-
 	/**
 	 * Move a file or folder in the cache
 	 *
@@ -657,19 +643,10 @@
 			$targetPath = $this->normalize($targetPath);
 
 			$sourceData = $sourceCache->get($sourcePath);
-			if (!$sourceData) {
+			if ($sourceData === false) {
 				throw new \Exception('Invalid source storage path: ' . $sourcePath);
 			}
 
-			$shardDefinition = $this->connection->getShardDefinition('filecache');
-			if (
-				$shardDefinition &&
-				$shardDefinition->getShardForKey($sourceCache->getNumericStorageId()) !== $shardDefinition->getShardForKey($this->getNumericStorageId())
-			) {
-				$this->moveFromStorageSharded($shardDefinition, $sourceCache, $sourceData, $targetPath);
-				return;
-			}
-
 			$sourceId = $sourceData['fileid'];
 			$newParentId = $this->getParentId($targetPath);
 
@@ -683,15 +660,11 @@
 				throw new \Exception('Invalid target storage id: ' . $targetStorageId);
 			}
 
+			$this->connection->beginTransaction();
 			if ($sourceData['mimetype'] === 'httpd/unix-directory') {
 				//update all child entries
 				$sourceLength = mb_strlen($sourcePath);
-
-				$childIds = $this->getChildIds($sourceStorageId, $sourcePath);
-
-				$childChunks = array_chunk($childIds, 1000);
-
-				$query = $this->getQueryBuilder();
+				$query = $this->connection->getQueryBuilder();
 
 				$fun = $query->func();
 				$newPathFunction = $fun->concat(
@@ -699,72 +672,28 @@
 					$fun->substring('path', $query->createNamedParameter($sourceLength + 1, IQueryBuilder::PARAM_INT))// +1 for the leading slash
 				);
 				$query->update('filecache')
+					->set('storage', $query->createNamedParameter($targetStorageId, IQueryBuilder::PARAM_INT))
 					->set('path_hash', $fun->md5($newPathFunction))
 					->set('path', $newPathFunction)
-					->whereStorageId($sourceStorageId)
-					->andWhere($query->expr()->in('fileid', $query->createParameter('files')));
+					->where($query->expr()->eq('storage', $query->createNamedParameter($sourceStorageId, IQueryBuilder::PARAM_INT)))
+					->andWhere($query->expr()->like('path', $query->createNamedParameter($this->connection->escapeLikeParameter($sourcePath) . '/%')));
 
-				if ($sourceStorageId !== $targetStorageId) {
-					$query->set('storage', $query->createNamedParameter($targetStorageId), IQueryBuilder::PARAM_INT);
-				}
-
-				// when moving from an encrypted storage to a non-encrypted storage remove the `encrypted` mark
-				if ($sourceCache->hasEncryptionWrapper() && !$this->hasEncryptionWrapper()) {
-					$query->set('encrypted', $query->createNamedParameter(0, IQueryBuilder::PARAM_INT));
-				}
-
-				// Retry transaction in case of RetryableException like deadlocks.
-				// Retry up to 4 times because we should receive up to 4 concurrent requests from the frontend
-				$retryLimit = 4;
-				for ($i = 1; $i <= $retryLimit; $i++) {
 					try {
-						$this->connection->beginTransaction();
-						foreach ($childChunks as $chunk) {
-							$query->setParameter('files', $chunk, IQueryBuilder::PARAM_INT_ARRAY);
-							$query->executeStatement();
-						}
-						break;
+					$query->execute();
 					} catch (\OC\DatabaseException $e) {
 						$this->connection->rollBack();
 						throw $e;
-					} catch (DbalException $e) {
-						$this->connection->rollBack();
-
-						if (!$e->isRetryable()) {
-							throw $e;
 						}
-
-						// Simply throw if we already retried 4 times.
-						if ($i === $retryLimit) {
-							throw $e;
-						}
-
-						// Sleep a bit to give some time to the other transaction to finish.
-						usleep(100 * 1000 * $i);
-					}
-				}
-			} else {
-				$this->connection->beginTransaction();
 			}
 
 			$query = $this->getQueryBuilder();
 			$query->update('filecache')
+				->set('storage', $query->createNamedParameter($targetStorageId))
 				->set('path', $query->createNamedParameter($targetPath))
 				->set('path_hash', $query->createNamedParameter(md5($targetPath)))
 				->set('name', $query->createNamedParameter(basename($targetPath)))
 				->set('parent', $query->createNamedParameter($newParentId, IQueryBuilder::PARAM_INT))
-				->whereStorageId($sourceStorageId)
 				->whereFileId($sourceId);
-
-			if ($sourceStorageId !== $targetStorageId) {
-				$query->set('storage', $query->createNamedParameter($targetStorageId), IQueryBuilder::PARAM_INT);
-			}
-
-			// when moving from an encrypted storage to a non-encrypted storage remove the `encrypted` mark
-			if ($sourceCache->hasEncryptionWrapper() && !$this->hasEncryptionWrapper()) {
-				$query->set('encrypted', $query->createNamedParameter(0, IQueryBuilder::PARAM_INT));
-			}
-
 			$query->execute();
 
 			$this->connection->commit();
@@ -784,22 +713,13 @@
 		}
 	}
 
-	private function getChildIds(int $storageId, string $path): array {
-		$query = $this->connection->getQueryBuilder();
-		$query->select('fileid')
-			->from('filecache')
-			->where($query->expr()->eq('storage', $query->createNamedParameter($storageId, IQueryBuilder::PARAM_INT)))
-			->andWhere($query->expr()->like('path', $query->createNamedParameter($this->connection->escapeLikeParameter($path) . '/%')));
-		return $query->executeQuery()->fetchAll(\PDO::FETCH_COLUMN);
-	}
-
 	/**
 	 * remove all entries for files that are stored on the storage from the cache
 	 */
 	public function clear() {
 		$query = $this->getQueryBuilder();
 		$query->delete('filecache')
-			->whereStorageId($this->getNumericStorageId());
+			->whereStorageId();
 		$query->execute();
 
 		$query = $this->connection->getQueryBuilder();
@@ -827,7 +747,7 @@
 		$query = $this->getQueryBuilder();
 		$query->select('size')
 			->from('filecache')
-			->whereStorageId($this->getNumericStorageId())
+			->whereStorageId()
 			->wherePath($file);
 
 		$result = $query->execute();
@@ -856,8 +776,37 @@
 	 * @return ICacheEntry[] an array of cache entries where the name matches the search pattern
 	 */
 	public function search($pattern) {
-		$operator = new SearchComparison(ISearchComparison::COMPARE_LIKE, 'name', $pattern);
-		return $this->searchQuery(new SearchQuery($operator, 0, 0, [], null));
+		// normalize pattern
+		$pattern = $this->normalize($pattern);
+
+		if ($pattern === '%%') {
+			return [];
+		}
+
+		$query = $this->getQueryBuilder();
+		$query->selectFileCache()
+			->whereStorageId()
+			->andWhere($query->expr()->iLike('name', $query->createNamedParameter($pattern)));
+
+		$result = $query->execute();
+		$files = $result->fetchAll();
+		$result->closeCursor();
+
+		return array_map(function (array $data) {
+			return self::cacheEntryFromData($data, $this->mimetypeLoader);
+		}, $files);
+	}
+
+	/**
+	 * @param IResult $result
+	 * @return CacheEntry[]
+	 */
+	private function searchResultToCacheEntries(IResult $result): array {
+		$files = $result->fetchAll();
+
+		return array_map(function (array $data) {
+			return self::cacheEntryFromData($data, $this->mimetypeLoader);
+		}, $files);
 	}
 
 	/**
@@ -868,16 +817,71 @@
 	 * @return ICacheEntry[] an array of cache entries where the mimetype matches the search
 	 */
 	public function searchByMime($mimetype) {
-		if (!str_contains($mimetype, '/')) {
-			$operator = new SearchComparison(ISearchComparison::COMPARE_LIKE, 'mimetype', $mimetype . '/%');
+		$mimeId = $this->mimetypeLoader->getId($mimetype);
+
+		$query = $this->getQueryBuilder();
+		$query->selectFileCache()
+			->whereStorageId();
+
+		if (strpos($mimetype, '/')) {
+			$query->andWhere($query->expr()->eq('mimetype', $query->createNamedParameter($mimeId, IQueryBuilder::PARAM_INT)));
 		} else {
-			$operator = new SearchComparison(ISearchComparison::COMPARE_EQUAL, 'mimetype', $mimetype);
+			$query->andWhere($query->expr()->eq('mimepart', $query->createNamedParameter($mimeId, IQueryBuilder::PARAM_INT)));
 		}
-		return $this->searchQuery(new SearchQuery($operator, 0, 0, [], null));
+
+		$result = $query->execute();
+		$files = $result->fetchAll();
+		$result->closeCursor();
+
+		return array_map(function (array $data) {
+			return self::cacheEntryFromData($data, $this->mimetypeLoader);
+		}, $files);
 	}
 
-	public function searchQuery(ISearchQuery $query) {
-		return current($this->querySearchHelper->searchInCaches($query, [$this]));
+	public function searchQuery(ISearchQuery $searchQuery) {
+		$builder = $this->getQueryBuilder();
+
+		$query = $builder->selectFileCache('file');
+
+		$query->whereStorageId();
+
+		if ($this->querySearchHelper->shouldJoinTags($searchQuery->getSearchOperation())) {
+			$user = $searchQuery->getUser();
+			if ($user === null) {
+				throw new \InvalidArgumentException("Searching by tag requires the user to be set in the query");
+			}
+			$query
+				->innerJoin('file', 'vcategory_to_object', 'tagmap', $builder->expr()->eq('file.fileid', 'tagmap.objid'))
+				->innerJoin('tagmap', 'vcategory', 'tag', $builder->expr()->andX(
+					$builder->expr()->eq('tagmap.type', 'tag.type'),
+					$builder->expr()->eq('tagmap.categoryid', 'tag.id')
+				))
+				->andWhere($builder->expr()->eq('tag.type', $builder->createNamedParameter('files')))
+				->andWhere($builder->expr()->eq('tag.uid', $builder->createNamedParameter($user->getUID())));
+		}
+
+		$searchExpr = $this->querySearchHelper->searchOperatorToDBExpr($builder, $searchQuery->getSearchOperation());
+		if ($searchExpr) {
+			$query->andWhere($searchExpr);
+		}
+
+		if ($searchQuery->limitToHome() && ($this instanceof HomeCache)) {
+			$query->andWhere($builder->expr()->like('path', $query->expr()->literal('files/%')));
+		}
+
+		$this->querySearchHelper->addSearchOrdersToQuery($query, $searchQuery->getOrder());
+
+		if ($searchQuery->getLimit()) {
+			$query->setMaxResults($searchQuery->getLimit());
+		}
+		if ($searchQuery->getOffset()) {
+			$query->setFirstResult($searchQuery->getOffset());
+		}
+
+		$result = $query->execute();
+		$cacheEntries = $this->searchResultToCacheEntries($result);
+		$result->closeCursor();
+		return $cacheEntries;
 	}
 
 	/**
@@ -890,7 +894,7 @@
 		$this->calculateFolderSize($path, $data);
 		if ($path !== '') {
 			$parent = dirname($path);
-			if ($parent === '.' || $parent === '/') {
+			if ($parent === '.' or $parent === '/') {
 				$parent = '';
 			}
 			if ($isBackgroundScan) {
@@ -916,7 +920,6 @@
 			$query->select($query->func()->count())
 				->from('filecache')
 				->whereParent($fileId)
-				->whereStorageId($this->getNumericStorageId())
 				->andWhere($query->expr()->lt('size', $query->createNamedParameter(0, IQueryBuilder::PARAM_INT)));
 
 			$result = $query->execute();
@@ -932,61 +935,30 @@
 	 * calculate the size of a folder and set it in the cache
 	 *
 	 * @param string $path
-	 * @param array|null|ICacheEntry $entry (optional) meta data of the folder
-	 * @return int|float
+	 * @param array $entry (optional) meta data of the folder
+	 * @return int
 	 */
 	public function calculateFolderSize($path, $entry = null) {
-		return $this->calculateFolderSizeInner($path, $entry);
-	}
-
-
-	/**
-	 * inner function because we can't add new params to the public function without breaking any child classes
-	 *
-	 * @param string $path
-	 * @param array|null|ICacheEntry $entry (optional) meta data of the folder
-	 * @param bool $ignoreUnknown don't mark the folder size as unknown if any of it's children are unknown
-	 * @return int|float
-	 */
-	protected function calculateFolderSizeInner(string $path, $entry = null, bool $ignoreUnknown = false) {
 		$totalSize = 0;
-		if (is_null($entry) || !isset($entry['fileid'])) {
+		if (is_null($entry) or !isset($entry['fileid'])) {
 			$entry = $this->get($path);
 		}
 		if (isset($entry['mimetype']) && $entry['mimetype'] === FileInfo::MIMETYPE_FOLDER) {
 			$id = $entry['fileid'];
 
 			$query = $this->getQueryBuilder();
-			$query->select('size', 'unencrypted_size')
+			$query->selectAlias($query->func()->sum('size'), 'f1')
+				->selectAlias($query->func()->min('size'), 'f2')
 				->from('filecache')
-				->whereStorageId($this->getNumericStorageId())
+				->whereStorageId()
 				->whereParent($id);
-			if ($ignoreUnknown) {
-				$query->andWhere($query->expr()->gte('size', $query->createNamedParameter(0)));
-			}
 
 			$result = $query->execute();
-			$rows = $result->fetchAll();
+			$row = $result->fetch();
 			$result->closeCursor();
 
-			if ($rows) {
-				$sizes = array_map(function (array $row) {
-					return Util::numericToNumber($row['size']);
-				}, $rows);
-				$unencryptedOnlySizes = array_map(function (array $row) {
-					return Util::numericToNumber($row['unencrypted_size']);
-				}, $rows);
-				$unencryptedSizes = array_map(function (array $row) {
-					return Util::numericToNumber(($row['unencrypted_size'] > 0) ? $row['unencrypted_size'] : $row['size']);
-				}, $rows);
-
-				$sum = array_sum($sizes);
-				$min = min($sizes);
-
-				$unencryptedSum = array_sum($unencryptedSizes);
-				$unencryptedMin = min($unencryptedSizes);
-				$unencryptedMax = max($unencryptedOnlySizes);
-
+			if ($row) {
+				[$sum, $min] = array_values($row);
 				$sum = 0 + $sum;
 				$min = 0 + $min;
 				if ($min === -1) {
@@ -994,34 +966,8 @@
 				} else {
 					$totalSize = $sum;
 				}
-				if ($unencryptedMin === -1 || $min === -1) {
-					$unencryptedTotal = $unencryptedMin;
-				} else {
-					$unencryptedTotal = $unencryptedSum;
-				}
-			} else {
-				$totalSize = 0;
-				$unencryptedTotal = 0;
-				$unencryptedMax = 0;
-			}
-
-			// only set unencrypted size for a folder if any child entries have it set, or the folder is empty
-			$shouldWriteUnEncryptedSize = $unencryptedMax > 0 || $totalSize === 0 || $entry['unencrypted_size'] > 0;
-			if ($entry['size'] !== $totalSize || ($entry['unencrypted_size'] !== $unencryptedTotal && $shouldWriteUnEncryptedSize)) {
-				if ($shouldWriteUnEncryptedSize) {
-					// if all children have an unencrypted size of 0, just set the folder unencrypted size to 0 instead of summing the sizes
-					if ($unencryptedMax === 0) {
-						$unencryptedTotal = 0;
-					}
-
-					$this->update($id, [
-						'size' => $totalSize,
-						'unencrypted_size' => $unencryptedTotal,
-					]);
-				} else {
-					$this->update($id, [
-						'size' => $totalSize,
-					]);
+				if ($entry['size'] !== $totalSize) {
+					$this->update($id, ['size' => $totalSize]);
 				}
 			}
 		}
@@ -1037,7 +983,7 @@
 		$query = $this->getQueryBuilder();
 		$query->select('fileid')
 			->from('filecache')
-			->whereStorageId($this->getNumericStorageId());
+			->whereStorageId();
 
 		$result = $query->execute();
 		$files = $result->fetchAll(\PDO::FETCH_COLUMN);
@@ -1055,31 +1001,22 @@
 	 * use the one with the highest id gives the best result with the background scanner, since that is most
 	 * likely the folder where we stopped scanning previously
 	 *
-	 * @return string|false the path of the folder or false when no folder matched
+	 * @return string|bool the path of the folder or false when no folder matched
 	 */
 	public function getIncomplete() {
-		// we select the fileid here first instead of directly selecting the path since this helps mariadb/mysql
-		// to use the correct index.
-		// The overhead of this should be minimal since the cost of selecting the path by id should be much lower
-		// than the cost of finding an item with size < 0
 		$query = $this->getQueryBuilder();
-		$query->select('fileid')
+		$query->select('path')
 			->from('filecache')
-			->whereStorageId($this->getNumericStorageId())
+			->whereStorageId()
 			->andWhere($query->expr()->lt('size', $query->createNamedParameter(0, IQueryBuilder::PARAM_INT)))
 			->orderBy('fileid', 'DESC')
 			->setMaxResults(1);
 
 		$result = $query->execute();
-		$id = $result->fetchOne();
+		$path = $result->fetchOne();
 		$result->closeCursor();
 
-		if ($id === false) {
-			return false;
-		}
-
-		$path = $this->getPathById($id);
-		return $path ?? false;
+		return $path;
 	}
 
 	/**
@@ -1092,7 +1029,7 @@
 		$query = $this->getQueryBuilder();
 		$query->select('path')
 			->from('filecache')
-			->whereStorageId($this->getNumericStorageId())
+			->whereStorageId()
 			->whereFileId($id);
 
 		$result = $query->execute();
@@ -1155,19 +1092,13 @@
 	 * @param ICache $sourceCache
 	 * @param ICacheEntry $sourceEntry
 	 * @param string $targetPath
-	 * @return int fileId of copied entry
+	 * @return int fileid of copied entry
 	 */
 	public function copyFromCache(ICache $sourceCache, ICacheEntry $sourceEntry, string $targetPath): int {
 		if ($sourceEntry->getId() < 0) {
 			throw new \RuntimeException("Invalid source cache entry on copyFromCache");
 		}
 		$data = $this->cacheEntryToArray($sourceEntry);
-
-		// when moving from an encrypted storage to a non-encrypted storage remove the `encrypted` mark
-		if ($sourceCache instanceof Cache && $sourceCache->hasEncryptionWrapper() && !$this->hasEncryptionWrapper()) {
-			$data['encrypted'] = 0;
-		}
-
 		$fileId = $this->put($targetPath, $data);
 		if ($fileId <= 0) {
 			throw new \RuntimeException("Failed to copy to " . $targetPath . " from cache with source data " . json_encode($data) . " ");
@@ -1197,84 +1128,4 @@
 			'metadata_etag' => $entry->getMetadataEtag(),
 		];
 	}
-
-	public function getQueryFilterForStorage(): ISearchOperator {
-		return new SearchComparison(ISearchComparison::COMPARE_EQUAL, 'storage', $this->getNumericStorageId());
-	}
-
-	public function getCacheEntryFromSearchResult(ICacheEntry $rawEntry): ?ICacheEntry {
-		if ($rawEntry->getStorageId() === $this->getNumericStorageId()) {
-			return $rawEntry;
-		} else {
-			return null;
-		}
-	}
-
-	private function moveFromStorageSharded(ShardDefinition $shardDefinition, ICache $sourceCache, ICacheEntry $sourceEntry, $targetPath): void {
-		if ($sourceEntry->getMimeType() === ICacheEntry::DIRECTORY_MIMETYPE) {
-			$fileIds = $this->getChildIds($sourceCache->getNumericStorageId(), $sourceEntry->getPath());
-		} else {
-			$fileIds = [];
-		}
-		$fileIds[] = $sourceEntry->getId();
-
-		$helper = $this->connection->getCrossShardMoveHelper();
-
-		$sourceConnection = $helper->getConnection($shardDefinition, $sourceCache->getNumericStorageId());
-		$targetConnection = $helper->getConnection($shardDefinition, $this->getNumericStorageId());
-
-		$cacheItems = $helper->loadItems($sourceConnection, 'filecache', 'fileid', $fileIds);
-		$extendedItems = $helper->loadItems($sourceConnection, 'filecache_extended', 'fileid', $fileIds);
-		$metadataItems = $helper->loadItems($sourceConnection, 'files_metadata', 'file_id', $fileIds);
-
-		// when moving from an encrypted storage to a non-encrypted storage remove the `encrypted` mark
-		$removeEncryptedFlag = ($sourceCache instanceof Cache && $sourceCache->hasEncryptionWrapper()) && !$this->hasEncryptionWrapper();
-
-		$sourcePathLength = strlen($sourceEntry->getPath());
-		foreach ($cacheItems as &$cacheItem) {
-			if ($cacheItem['path'] === $sourceEntry->getPath()) {
-				$cacheItem['path'] = $targetPath;
-				$cacheItem['parent'] = $this->getParentId($targetPath);
-				$cacheItem['name'] = basename($cacheItem['path']);
-			} else {
-				$cacheItem['path'] = $targetPath . '/' . substr($cacheItem['path'], $sourcePathLength + 1); // +1 for the leading slash
-			}
-			$cacheItem['path_hash'] = md5($cacheItem['path']);
-			$cacheItem['storage'] = $this->getNumericStorageId();
-			if ($removeEncryptedFlag) {
-				$cacheItem['encrypted'] = 0;
-			}
-		}
-
-		$targetConnection->beginTransaction();
-
-		try {
-			$helper->saveItems($targetConnection, 'filecache', $cacheItems);
-			$helper->saveItems($targetConnection, 'filecache_extended', $extendedItems);
-			$helper->saveItems($targetConnection, 'files_metadata', $metadataItems);
-		} catch (\Exception $e) {
-			$targetConnection->rollback();
-			throw $e;
-		}
-
-		$sourceConnection->beginTransaction();
-
-		try {
-			$helper->deleteItems($sourceConnection, 'filecache', 'fileid', $fileIds);
-			$helper->deleteItems($sourceConnection, 'filecache_extended', 'fileid', $fileIds);
-			$helper->deleteItems($sourceConnection, 'files_metadata', 'file_id', $fileIds);
-		} catch (\Exception $e) {
-			$targetConnection->rollback();
-			$sourceConnection->rollBack();
-			throw $e;
-		}
-
-		try {
-			$sourceConnection->commit();
-		} catch (\Exception $e) {
-			$targetConnection->rollback();
-			throw $e;
-		}
-		$targetConnection->commit();
-	}
 }
