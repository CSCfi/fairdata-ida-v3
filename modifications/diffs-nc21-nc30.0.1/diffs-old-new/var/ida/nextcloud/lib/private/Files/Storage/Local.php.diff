--- /var/ida/nextcloud-new/lib/private/Files/Storage/Local.php	2024-11-05 08:30:09.649707044 +0000
+++ /var/ida/nextcloud-old/lib/private/Files/Storage/Local.php	2024-02-20 10:11:39.293443321 +0000
@@ -1,24 +1,54 @@
 <?php
-
 /**
- * SPDX-FileCopyrightText: 2016-2024 Nextcloud GmbH and Nextcloud contributors
- * SPDX-FileCopyrightText: 2016 ownCloud, Inc.
- * SPDX-License-Identifier: AGPL-3.0-only
+ * @copyright Copyright (c) 2016, ownCloud, Inc.
+ *
+ * @author aler9 <46489434+aler9@users.noreply.github.com>
+ * @author Arthur Schiwon <blizzz@arthur-schiwon.de>
+ * @author Bart Visscher <bartv@thisnet.nl>
+ * @author Boris Rybalkin <ribalkin@gmail.com>
+ * @author Brice Maron <brice@bmaron.net>
+ * @author Christoph Wurst <christoph@winzerhof-wurst.at>
+ * @author J0WI <J0WI@users.noreply.github.com>
+ * @author Jakob Sack <mail@jakobsack.de>
+ * @author Joas Schilling <coding@schilljs.com>
+ * @author Jörn Friedrich Dreyer <jfd@butonic.de>
+ * @author Klaas Freitag <freitag@owncloud.com>
+ * @author Lukas Reschke <lukas@statuscode.ch>
+ * @author Michael Gapczynski <GapczynskiM@gmail.com>
+ * @author Morris Jobke <hey@morrisjobke.de>
+ * @author Robin Appelman <robin@icewind.nl>
+ * @author Roeland Jago Douma <roeland@famdouma.nl>
+ * @author Sjors van der Pluijm <sjors@desjors.nl>
+ * @author Stefan Weil <sw@weilnetz.de>
+ * @author Thomas Müller <thomas.mueller@tmit.eu>
+ * @author Tigran Mkrtchyan <tigran.mkrtchyan@desy.de>
+ * @author Vincent Petry <vincent@nextcloud.com>
+ *
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program. If not, see <http://www.gnu.org/licenses/>
+ *
  */
+
 namespace OC\Files\Storage;
 
 use OC\Files\Filesystem;
-use OC\Files\Storage\Wrapper\Encryption;
 use OC\Files\Storage\Wrapper\Jail;
 use OCP\Constants;
 use OCP\Files\ForbiddenException;
 use OCP\Files\GenericFileException;
-use OCP\Files\IMimeTypeDetector;
 use OCP\Files\Storage\IStorage;
-use OCP\Files\StorageNotAvailableException;
-use OCP\IConfig;
-use OCP\Util;
-use Psr\Log\LoggerInterface;
+use OCP\ILogger;
 
 /**
  * for local filestore, we only have to map the paths
@@ -30,16 +60,6 @@
 
 	protected $realDataDir;
 
-	private IConfig $config;
-
-	private IMimeTypeDetector $mimeTypeDetector;
-
-	private $defUMask;
-
-	protected bool $unlinkOnTruncate;
-
-	protected bool $caseInsensitive = false;
-
 	public function __construct($arguments) {
 		if (!isset($arguments['datadir']) || !is_string($arguments['datadir'])) {
 			throw new \InvalidArgumentException('No data directory set for local storage');
@@ -52,23 +72,10 @@
 			$realPath = realpath($this->datadir) ?: $this->datadir;
 			$this->realDataDir = rtrim($realPath, '/') . '/';
 		}
-		if (!str_ends_with($this->datadir, '/')) {
+		if (substr($this->datadir, -1) !== '/') {
 			$this->datadir .= '/';
 		}
 		$this->dataDirLength = strlen($this->realDataDir);
-		$this->config = \OC::$server->get(IConfig::class);
-		$this->mimeTypeDetector = \OC::$server->get(IMimeTypeDetector::class);
-		$this->defUMask = $this->config->getSystemValue('localstorage.umask', 0022);
-		$this->caseInsensitive = $this->config->getSystemValueBool('localstorage.case_insensitive', false);
-
-		// support Write-Once-Read-Many file systems
-		$this->unlinkOnTruncate = $this->config->getSystemValueBool('localstorage.unlink_on_truncate', false);
-
-		if (isset($arguments['isExternal']) && $arguments['isExternal'] && !$this->stat('')) {
-			// data dir not accessible or available, can happen when using an external storage of type Local
-			// on an unmounted system mount point
-			throw new StorageNotAvailableException('Local storage path does not exist "' . $this->getSourcePath('') . '"');
-		}
 	}
 
 	public function __destruct() {
@@ -80,7 +87,7 @@
 
 	public function mkdir($path) {
 		$sourcePath = $this->getSourcePath($path);
-		$oldMask = umask($this->defUMask);
+		$oldMask = umask(022);
 		$result = @mkdir($sourcePath, 0777, true);
 		umask($oldMask);
 		return $result;
@@ -106,20 +113,23 @@
 				 * @var \SplFileInfo $file
 				 */
 				$file = $it->current();
-				clearstatcache(true, $file->getRealPath());
+				clearstatcache(true, $this->getSourcePath($file));
 				if (in_array($file->getBasename(), ['.', '..'])) {
 					$it->next();
 					continue;
-				} elseif ($file->isFile() || $file->isLink()) {
-					unlink($file->getPathname());
 				} elseif ($file->isDir()) {
-					rmdir($file->getPathname());
+					// rmdir($file->getPathname());  BUG: This fails if the directory is not empty. Using system call instead.
+					@system('rm -rf -- ' . escapeshellarg($file->getPathname()), $retval);
+					if ($retval != 0) {
+				        throw new \Exception('Failed to remove directory: ' . $file->getPathname(), false);
+					}
+				} elseif ($file->isFile() || $file->isLink()) {
+					@unlink($file->getPathname());
 				}
 				$it->next();
 			}
-			unset($it);  // Release iterator and thereby its potential directory lock (e.g. in case of VirtualBox shared folders)
 			clearstatcache(true, $this->getSourcePath($path));
-			return rmdir($this->getSourcePath($path));
+			return @rmdir($this->getSourcePath($path));
 		} catch (\UnexpectedValueException $e) {
 			return false;
 		}
@@ -130,37 +140,25 @@
 	}
 
 	public function is_dir($path) {
-		if ($this->caseInsensitive && !$this->file_exists($path)) {
-			return false;
-		}
-		if (str_ends_with($path, '/')) {
+		if (substr($path, -1) == '/') {
 			$path = substr($path, 0, -1);
 		}
 		return is_dir($this->getSourcePath($path));
 	}
 
 	public function is_file($path) {
-		if ($this->caseInsensitive && !$this->file_exists($path)) {
-			return false;
-		}
 		return is_file($this->getSourcePath($path));
 	}
 
 	public function stat($path) {
 		$fullPath = $this->getSourcePath($path);
 		clearstatcache(true, $fullPath);
-		if (!file_exists($fullPath)) {
-			return false;
-		}
 		$statResult = @stat($fullPath);
 		if (PHP_INT_SIZE === 4 && $statResult && !$this->is_dir($path)) {
 			$filesize = $this->filesize($path);
 			$statResult['size'] = $filesize;
 			$statResult[7] = $filesize;
 		}
-		if (is_array($statResult)) {
-			$statResult['full_path'] = $fullPath;
-		}
 		return $statResult;
 	}
 
@@ -168,18 +166,14 @@
 	 * @inheritdoc
 	 */
 	public function getMetaData($path) {
-		try {
 			$stat = $this->stat($path);
-		} catch (ForbiddenException $e) {
-			return null;
-		}
 		if (!$stat) {
 			return null;
 		}
 
 		$permissions = Constants::PERMISSION_SHARE;
 		$statPermissions = $stat['mode'];
-		$isDir = ($statPermissions & 0x4000) === 0x4000 && !($statPermissions & 0x8000);
+		$isDir = ($statPermissions & 0x4000) === 0x4000;
 		if ($statPermissions & 0x0100) {
 			$permissions += Constants::PERMISSION_READ;
 		}
@@ -191,14 +185,15 @@
 		}
 
 		if (!($path === '' || $path === '/')) { // deletable depends on the parents unix permissions
-			$parent = dirname($stat['full_path']);
+			$fullPath = $this->getSourcePath($path);
+			$parent = dirname($fullPath);
 			if (is_writable($parent)) {
 				$permissions += Constants::PERMISSION_DELETE;
 			}
 		}
 
 		$data = [];
-		$data['mimetype'] = $isDir ? 'httpd/unix-directory' : $this->mimeTypeDetector->detectPath($path);
+		$data['mimetype'] = $isDir ? 'httpd/unix-directory' : \OC::$server->getMimeTypeDetector()->detectPath($path);
 		$data['mtime'] = $stat['mtime'];
 		if ($data['mtime'] === false) {
 			$data['mtime'] = time();
@@ -224,8 +219,8 @@
 		return $filetype;
 	}
 
-	public function filesize($path): false|int|float {
-		if (!$this->is_file($path)) {
+	public function filesize($path) {
+		if ($this->is_dir($path)) {
 			return 0;
 		}
 		$fullPath = $this->getSourcePath($path);
@@ -245,18 +240,8 @@
 	}
 
 	public function file_exists($path) {
-		if ($this->caseInsensitive) {
-			$fullPath = $this->getSourcePath($path);
-			$parentPath = dirname($fullPath);
-			if (!is_dir($parentPath)) {
-				return false;
-			}
-			$content = scandir($parentPath, SCANDIR_SORT_NONE);
-			return is_array($content) && array_search(basename($fullPath), $content) !== false;
-		} else {
 			return file_exists($this->getSourcePath($path));
 		}
-	}
 
 	public function filemtime($path) {
 		$fullPath = $this->getSourcePath($path);
@@ -278,7 +263,7 @@
 		if ($this->file_exists($path) and !$this->isUpdatable($path)) {
 			return false;
 		}
-		$oldMask = umask($this->defUMask);
+		$oldMask = umask(022);
 		if (!is_null($mtime)) {
 			$result = @touch($this->getSourcePath($path), $mtime);
 		} else {
@@ -297,10 +282,7 @@
 	}
 
 	public function file_put_contents($path, $data) {
-		$oldMask = umask($this->defUMask);
-		if ($this->unlinkOnTruncate) {
-			$this->unlink($path);
-		}
+		$oldMask = umask(022);
 		$result = file_put_contents($this->getSourcePath($path), $data);
 		umask($oldMask);
 		return $result;
@@ -326,81 +308,68 @@
 		}
 	}
 
-	public function rename($source, $target): bool {
-		$srcParent = dirname($source);
-		$dstParent = dirname($target);
+	public function rename($path1, $path2) {
+		$srcParent = dirname($path1);
+		$dstParent = dirname($path2);
 
 		if (!$this->isUpdatable($srcParent)) {
-			\OC::$server->get(LoggerInterface::class)->error('unable to rename, source directory is not writable : ' . $srcParent, ['app' => 'core']);
+			\OCP\Util::writeLog('core', 'unable to rename, source directory is not writable : ' . $srcParent, ILogger::ERROR);
 			return false;
 		}
 
 		if (!$this->isUpdatable($dstParent)) {
-			\OC::$server->get(LoggerInterface::class)->error('unable to rename, destination directory is not writable : ' . $dstParent, ['app' => 'core']);
+			\OCP\Util::writeLog('core', 'unable to rename, destination directory is not writable : ' . $dstParent, ILogger::ERROR);
 			return false;
 		}
 
-		if (!$this->file_exists($source)) {
-			\OC::$server->get(LoggerInterface::class)->error('unable to rename, file does not exists : ' . $source, ['app' => 'core']);
+		if (!$this->file_exists($path1)) {
+			\OCP\Util::writeLog('core', 'unable to rename, file does not exists : ' . $path1, ILogger::ERROR);
 			return false;
 		}
 
-		if ($this->is_dir($target)) {
-			$this->rmdir($target);
-		} elseif ($this->is_file($target)) {
-			$this->unlink($target);
-		}
-
-		if ($this->is_dir($source)) {
-			$this->checkTreeForForbiddenItems($this->getSourcePath($source));
+		if ($this->is_dir($path2)) {
+			$this->rmdir($path2);
+		} elseif ($this->is_file($path2)) {
+			$this->unlink($path2);
 		}
 
-		if (@rename($this->getSourcePath($source), $this->getSourcePath($target))) {
-			if ($this->caseInsensitive) {
-				if (mb_strtolower($target) === mb_strtolower($source) && !$this->file_exists($target)) {
-					return false;
+		if ($this->is_dir($path1)) {
+			// we can't move folders across devices, use copy instead
+			$stat1 = stat(dirname($this->getSourcePath($path1)));
+			$stat2 = stat(dirname($this->getSourcePath($path2)));
+			if ($stat1['dev'] !== $stat2['dev']) {
+				$result = $this->copy($path1, $path2);
+				if ($result) {
+					$result &= $this->rmdir($path1);
 				}
+				return $result;
 			}
-			return true;
+
+			$this->checkTreeForForbiddenItems($this->getSourcePath($path1));
 		}
 
-		return $this->copy($source, $target) && $this->unlink($source);
+		return rename($this->getSourcePath($path1), $this->getSourcePath($path2));
 	}
 
-	public function copy($source, $target) {
-		if ($this->is_dir($source)) {
-			return parent::copy($source, $target);
+	public function copy($path1, $path2) {
+		if ($this->is_dir($path1)) {
+			return parent::copy($path1, $path2);
 		} else {
-			$oldMask = umask($this->defUMask);
-			if ($this->unlinkOnTruncate) {
-				$this->unlink($target);
-			}
-			$result = copy($this->getSourcePath($source), $this->getSourcePath($target));
+			$oldMask = umask(022);
+			$result = copy($this->getSourcePath($path1), $this->getSourcePath($path2));
 			umask($oldMask);
-			if ($this->caseInsensitive) {
-				if (mb_strtolower($target) === mb_strtolower($source) && !$this->file_exists($target)) {
-					return false;
-				}
-			}
 			return $result;
 		}
 	}
 
 	public function fopen($path, $mode) {
-		$sourcePath = $this->getSourcePath($path);
-		if (!file_exists($sourcePath) && $mode === 'r') {
-			return false;
-		}
-		$oldMask = umask($this->defUMask);
-		if (($mode === 'w' || $mode === 'w+') && $this->unlinkOnTruncate) {
-			$this->unlink($path);
-		}
-		$result = @fopen($sourcePath, $mode);
+		$oldMask = umask(022);
+		$result = @fopen($this->getSourcePath($path), $mode);
 		umask($oldMask);
 		return $result;
 	}
 
-	public function hash($type, $path, $raw = false): string|false {
+	public function hash($type, $path, $raw = false) {
 		return hash_file($type, $this->getSourcePath($path), $raw);
 	}
 
@@ -413,11 +382,11 @@
 			// disk_free_space doesn't work on files
 			$sourcePath = dirname($sourcePath);
 		}
-		$space = (function_exists('disk_free_space') && is_dir($sourcePath)) ? disk_free_space($sourcePath) : false;
+		$space = @disk_free_space($sourcePath);
 		if ($space === false || is_null($space)) {
 			return \OCP\Files\FileInfo::SPACE_UNKNOWN;
 		}
-		return Util::numericToNumber($space);
+		return $space;
 	}
 
 	public function search($query) {
@@ -428,6 +397,10 @@
 		return $this->getSourcePath($path);
 	}
 
+	public function getLocalFolder($path) {
+		return $this->getSourcePath($path);
+	}
+
 	/**
 	 * @param string $query
 	 * @param string $dir
@@ -481,7 +454,7 @@
 
 		$fullPath = $this->datadir . $path;
 		$currentPath = $path;
-		$allowSymlinks = $this->config->getSystemValueBool('localstorage.allowsymlinks', false);
+		$allowSymlinks = \OC::$server->getConfig()->getSystemValue('localstorage.allowsymlinks', false);
 		if ($allowSymlinks || $currentPath === '') {
 			return $fullPath;
 		}
@@ -489,7 +462,6 @@
 		$realPath = realpath($pathToResolve);
 		while ($realPath === false) { // for non existing files check the parent directory
 			$currentPath = dirname($currentPath);
-			/** @psalm-suppress TypeDoesNotContainType Let's be extra cautious and still check for empty string */
 			if ($currentPath === '' || $currentPath === '.') {
 				return $fullPath;
 			}
@@ -502,7 +474,11 @@
 			return $fullPath;
 		}
 
-		\OC::$server->get(LoggerInterface::class)->error("Following symlinks is not allowed ('$fullPath' -> '$realPath' not inside '{$this->realDataDir}')", ['app' => 'core']);
+	    if (strpos($realPath, "/mnt/storage_vol0") === 0) {
+			return $fullPath;
+		}
+
+		\OCP\Util::writeLog('core', "Following symlinks is not allowed ('$fullPath' -> '$realPath' not inside '{$this->realDataDir}')", ILogger::ERROR);
 		throw new ForbiddenException('Following symlinks is not allowed', false);
 	}
 
@@ -524,7 +500,7 @@
 	}
 
 	private function calculateEtag(string $path, array $stat): string {
-		if ($stat['mode'] & 0x4000 && !($stat['mode'] & 0x8000)) { // is_dir & not socket
+		if ($stat['mode'] & 0x4000) { // is_dir
 			return parent::getETag($path);
 		} else {
 			if ($stat === false) {
@@ -549,19 +525,6 @@
 		}
 	}
 
-	private function canDoCrossStorageMove(IStorage $sourceStorage) {
-		/** @psalm-suppress UndefinedClass */
-		return $sourceStorage->instanceOfStorage(Local::class)
-			// Don't treat ACLStorageWrapper like local storage where copy can be done directly.
-			// Instead, use the slower recursive copying in php from Common::copyFromStorage with
-			// more permissions checks.
-			&& !$sourceStorage->instanceOfStorage('OCA\GroupFolders\ACL\ACLStorageWrapper')
-			// Same for access control
-			&& !$sourceStorage->instanceOfStorage(\OCA\FilesAccessControl\StorageWrapper::class)
-			// when moving encrypted files we have to handle keys and the target might not be encrypted
-			&& !$sourceStorage->instanceOfStorage(Encryption::class);
-	}
-
 	/**
 	 * @param IStorage $sourceStorage
 	 * @param string $sourceInternalPath
@@ -570,7 +533,7 @@
 	 * @return bool
 	 */
 	public function copyFromStorage(IStorage $sourceStorage, $sourceInternalPath, $targetInternalPath, $preserveMtime = false) {
-		if ($this->canDoCrossStorageMove($sourceStorage)) {
+		if ($sourceStorage->instanceOfStorage(Local::class)) {
 			if ($sourceStorage->instanceOfStorage(Jail::class)) {
 				/**
 				 * @var \OC\Files\Storage\Wrapper\Jail $sourceStorage
@@ -594,7 +557,7 @@
 	 * @return bool
 	 */
 	public function moveFromStorage(IStorage $sourceStorage, $sourceInternalPath, $targetInternalPath) {
-		if ($this->canDoCrossStorageMove($sourceStorage)) {
+		if ($sourceStorage->instanceOfStorage(Local::class)) {
 			if ($sourceStorage->instanceOfStorage(Jail::class)) {
 				/**
 				 * @var \OC\Files\Storage\Wrapper\Jail $sourceStorage
@@ -611,14 +574,10 @@
 		}
 	}
 
-	public function writeStream(string $path, $stream, ?int $size = null): int {
-		/** @var int|false $result We consider here that returned size will never be a float because we write less than 4GB */
+	public function writeStream(string $path, $stream, int $size = null): int {
 		$result = $this->file_put_contents($path, $stream);
-		if (is_resource($stream)) {
-			fclose($stream);
-		}
 		if ($result === false) {
-			throw new GenericFileException("Failed write stream to $path");
+			throw new GenericFileException("Failed write steam to $path");
 		} else {
 			return $result;
 		}
