--- /var/ida/nextcloud-new/lib/private/Files/View.php	2024-11-05 08:30:09.651707051 +0000
+++ /var/ida/nextcloud-old/lib/private/Files/View.php	2024-02-20 10:11:39.296443331 +0000
@@ -1,39 +1,74 @@
 <?php
-
 /**
- * SPDX-FileCopyrightText: 2016-2024 Nextcloud GmbH and Nextcloud contributors
- * SPDX-FileCopyrightText: 2016 ownCloud, Inc.
- * SPDX-License-Identifier: AGPL-3.0-only
+ * @copyright Copyright (c) 2016, ownCloud, Inc.
+ *
+ * @author Arthur Schiwon <blizzz@arthur-schiwon.de>
+ * @author Ashod Nakashian <ashod.nakashian@collabora.co.uk>
+ * @author Bart Visscher <bartv@thisnet.nl>
+ * @author Björn Schießle <bjoern@schiessle.org>
+ * @author Christoph Wurst <christoph@winzerhof-wurst.at>
+ * @author Florin Peter <github@florin-peter.de>
+ * @author Jesús Macias <jmacias@solidgear.es>
+ * @author Joas Schilling <coding@schilljs.com>
+ * @author Jörn Friedrich Dreyer <jfd@butonic.de>
+ * @author Julius Härtl <jus@bitgrid.net>
+ * @author karakayasemi <karakayasemi@itu.edu.tr>
+ * @author Klaas Freitag <freitag@owncloud.com>
+ * @author korelstar <korelstar@users.noreply.github.com>
+ * @author Lukas Reschke <lukas@statuscode.ch>
+ * @author Luke Policinski <lpolicinski@gmail.com>
+ * @author Michael Gapczynski <GapczynskiM@gmail.com>
+ * @author Morris Jobke <hey@morrisjobke.de>
+ * @author Piotr Filiciak <piotr@filiciak.pl>
+ * @author Robin Appelman <robin@icewind.nl>
+ * @author Robin McCorkell <robin@mccorkell.me.uk>
+ * @author Roeland Jago Douma <roeland@famdouma.nl>
+ * @author Sam Tuke <mail@samtuke.com>
+ * @author Scott Dutton <exussum12@users.noreply.github.com>
+ * @author Thomas Müller <thomas.mueller@tmit.eu>
+ * @author Thomas Tanghus <thomas@tanghus.net>
+ * @author Vincent Petry <vincent@nextcloud.com>
+ *
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program. If not, see <http://www.gnu.org/licenses/>
+ *
  */
+
 namespace OC\Files;
 
 use Icewind\Streams\CallbackWrapper;
 use OC\Files\Mount\MoveableMount;
 use OC\Files\Storage\Storage;
-use OC\Share\Share;
-use OC\User\LazyUser;
-use OC\User\Manager as UserManager;
 use OC\User\User;
 use OCA\Files_Sharing\SharedMount;
 use OCP\Constants;
 use OCP\Files\Cache\ICacheEntry;
-use OCP\Files\ConnectionLostException;
 use OCP\Files\EmptyFileNameException;
 use OCP\Files\FileNameTooLongException;
-use OCP\Files\ForbiddenException;
 use OCP\Files\InvalidCharacterInPathException;
 use OCP\Files\InvalidDirectoryException;
 use OCP\Files\InvalidPathException;
 use OCP\Files\Mount\IMountPoint;
 use OCP\Files\NotFoundException;
 use OCP\Files\ReservedWordException;
+use OCP\Files\Storage\IStorage;
+use OCP\ILogger;
 use OCP\IUser;
 use OCP\Lock\ILockingProvider;
 use OCP\Lock\LockedException;
-use OCP\Server;
-use OCP\Share\IManager;
-use OCP\Share\IShare;
-use Psr\Log\LoggerInterface;
+use OCA\IDA\Controller\DataChangeController;
+use OCP\Util;
 
 /**
  * Class to provide access to ownCloud filesystem via a "view", and methods for
@@ -52,35 +87,57 @@
  * \OC\Files\Storage\Storage object
  */
 class View {
-	private string $fakeRoot = '';
-	private ILockingProvider $lockingProvider;
-	private bool $lockingEnabled;
-	private bool $updaterEnabled = true;
-	private UserManager $userManager;
-	private LoggerInterface $logger;
+	/** @var string */
+	private $fakeRoot = '';
+
+	/**
+	 * @var \OCP\Lock\ILockingProvider
+	 */
+	protected $lockingProvider;
+
+	private $lockingEnabled;
+
+	private $updaterEnabled = true;
+
+	/** @var \OC\User\Manager */
+	private $userManager;
+
+	/** @var \OCP\ILogger */
+	private $logger;
+
+	protected $idaUser = null;
+	protected $idaMode = 'API';
 
 	/**
+	 * @param string $root
 	 * @throws \Exception If $root contains an invalid path
 	 */
-	public function __construct(string $root = '') {
+	public function __construct($root = '') {
+		if (is_null($root)) {
+			throw new \InvalidArgumentException('Root can\'t be null');
+		}
 		if (!Filesystem::isValidPath($root)) {
 			throw new \Exception();
 		}
 
 		$this->fakeRoot = $root;
-		$this->lockingProvider = \OC::$server->get(ILockingProvider::class);
+		$this->lockingProvider = \OC::$server->getLockingProvider();
 		$this->lockingEnabled = !($this->lockingProvider instanceof \OC\Lock\NoopLockingProvider);
 		$this->userManager = \OC::$server->getUserManager();
-		$this->logger = \OC::$server->get(LoggerInterface::class);
+		$this->logger = \OC::$server->getLogger();
+
+		//Util::writeLog('ida', 'View init: server=' . json_encode($_SERVER), \OCP\Util::DEBUG);
+		if (isset($_SERVER['HTTP_IDA_AUTHENTICATED_USER'])) {
+			$this->idaUser = $_SERVER['HTTP_IDA_AUTHENTICATED_USER'];
+		}
+		if (isset($_SERVER['HTTP_IDA_MODE'])) {
+			$values = explode(',', $_SERVER['HTTP_IDA_MODE']);
+			$this->idaMode = $values[0];
+		}
+		Util::writeLog('ida', 'View init: idaUser=' . $this->idaUser . ' idaMode=' . $this->idaMode, \OCP\Util::DEBUG);
 	}
 
-	/**
-	 * @param ?string $path
-	 * @psalm-template S as string|null
-	 * @psalm-param S $path
-	 * @psalm-return (S is string ? string : null)
-	 */
-	public function getAbsolutePath($path = '/'): ?string {
+	public function getAbsolutePath($path = '/') {
 		if ($path === null) {
 			return null;
 		}
@@ -95,11 +152,12 @@
 	}
 
 	/**
-	 * Change the root to a fake root
+	 * change the root to a fake root
 	 *
 	 * @param string $fakeRoot
+	 * @return boolean|null
 	 */
-	public function chroot($fakeRoot): void {
+	public function chroot($fakeRoot) {
 		if (!$fakeRoot == '') {
 			if ($fakeRoot[0] !== '/') {
 				$fakeRoot = '/' . $fakeRoot;
@@ -109,9 +167,11 @@
 	}
 
 	/**
-	 * Get the fake root
+	 * get the fake root
+	 *
+	 * @return string
 	 */
-	public function getRoot(): string {
+	public function getRoot() {
 		return $this->fakeRoot;
 	}
 
@@ -119,8 +179,9 @@
 	 * get path relative to the root of the view
 	 *
 	 * @param string $path
+	 * @return string
 	 */
-	public function getRelativePath($path): ?string {
+	public function getRelativePath($path) {
 		$this->assertPathLength($path);
 		if ($this->fakeRoot == '') {
 			return $path;
@@ -133,7 +194,7 @@
 		// missing slashes can cause wrong matches!
 		$root = rtrim($this->fakeRoot, '/') . '/';
 
-		if (!str_starts_with($path, $root)) {
+		if (strpos($path, $root) !== 0) {
 			return null;
 		} else {
 			$path = substr($path, strlen($this->fakeRoot));
@@ -146,56 +207,74 @@
 	}
 
 	/**
-	 * Get the mountpoint of the storage object for a path
+	 * get the mountpoint of the storage object for a path
 	 * ( note: because a storage is not always mounted inside the fakeroot, the
 	 * returned mountpoint is relative to the absolute root of the filesystem
 	 * and does not take the chroot into account )
 	 *
 	 * @param string $path
+	 * @return string
 	 */
-	public function getMountPoint($path): string {
+	public function getMountPoint($path) {
 		return Filesystem::getMountPoint($this->getAbsolutePath($path));
 	}
 
 	/**
-	 * Get the mountpoint of the storage object for a path
+	 * get the mountpoint of the storage object for a path
 	 * ( note: because a storage is not always mounted inside the fakeroot, the
 	 * returned mountpoint is relative to the absolute root of the filesystem
 	 * and does not take the chroot into account )
 	 *
 	 * @param string $path
+	 * @return \OCP\Files\Mount\IMountPoint
 	 */
-	public function getMount($path): IMountPoint {
+	public function getMount($path) {
 		return Filesystem::getMountManager()->find($this->getAbsolutePath($path));
 	}
 
 	/**
-	 * Resolve a path to a storage and internal path
+	 * resolve a path to a storage and internal path
 	 *
 	 * @param string $path
-	 * @return array{?\OCP\Files\Storage\IStorage, string} an array consisting of the storage and the internal path
+	 * @return array an array consisting of the storage and the internal path
 	 */
-	public function resolvePath($path): array {
+	public function resolvePath($path) {
 		$a = $this->getAbsolutePath($path);
 		$p = Filesystem::normalizePath($a);
 		return Filesystem::resolvePath($p);
 	}
 
 	/**
-	 * Return the path to a local version of the file
+	 * return the path to a local version of the file
 	 * we need this because we can't know if a file is stored local or not from
 	 * outside the filestorage and for some purposes a local file is needed
 	 *
 	 * @param string $path
+	 * @return string
 	 */
-	public function getLocalFile($path): string|false {
-		$parent = substr($path, 0, strrpos($path, '/') ?: 0);
+	public function getLocalFile($path) {
+		$parent = substr($path, 0, strrpos($path, '/'));
 		$path = $this->getAbsolutePath($path);
 		[$storage, $internalPath] = Filesystem::resolvePath($path);
-		if (Filesystem::isValidPath($parent) && $storage) {
+		if (Filesystem::isValidPath($parent) and $storage) {
 			return $storage->getLocalFile($internalPath);
 		} else {
-			return false;
+			return null;
+		}
+	}
+
+	/**
+	 * @param string $path
+	 * @return string
+	 */
+	public function getLocalFolder($path) {
+		$parent = substr($path, 0, strrpos($path, '/'));
+		$path = $this->getAbsolutePath($path);
+		[$storage, $internalPath] = Filesystem::resolvePath($path);
+		if (Filesystem::isValidPath($parent) and $storage) {
+			return $storage->getLocalFolder($internalPath);
+		} else {
+			return null;
 		}
 	}
 
@@ -205,16 +284,19 @@
 	 * for \OC\Files\Storage\Storage via basicOperation().
 	 */
 	public function mkdir($path) {
-		return $this->basicOperation('mkdir', $path, ['create', 'write']);
+		$result = $this->basicOperation('mkdir', $path, ['create', 'write']);
+        DataChangeController::processNextcloudOperation('add', $path, null, $this->idaUser, $this->idaMode);
+		return $result;
 	}
 
 	/**
 	 * remove mount point
 	 *
-	 * @param IMountPoint $mount
+	 * @param \OC\Files\Mount\MoveableMount $mount
 	 * @param string $path relative to data/
+	 * @return boolean
 	 */
-	protected function removeMount($mount, $path): bool {
+	protected function removeMount($mount, $path) {
 		if ($mount instanceof MoveableMount) {
 			// cut of /user/files to get the relative path to data/user/files
 			$pathParts = explode('/', $path, 4);
@@ -243,30 +325,30 @@
 		}
 	}
 
-	public function disableCacheUpdate(): void {
+	public function disableCacheUpdate() {
 		$this->updaterEnabled = false;
 	}
 
-	public function enableCacheUpdate(): void {
+	public function enableCacheUpdate() {
 		$this->updaterEnabled = true;
 	}
 
-	protected function writeUpdate(Storage $storage, string $internalPath, ?int $time = null, ?int $sizeDifference = null): void {
+	protected function writeUpdate(Storage $storage, $internalPath, $time = null) {
 		if ($this->updaterEnabled) {
 			if (is_null($time)) {
 				$time = time();
 			}
-			$storage->getUpdater()->update($internalPath, $time, $sizeDifference);
+			$storage->getUpdater()->update($internalPath, $time);
 		}
 	}
 
-	protected function removeUpdate(Storage $storage, string $internalPath): void {
+	protected function removeUpdate(Storage $storage, $internalPath) {
 		if ($this->updaterEnabled) {
 			$storage->getUpdater()->remove($internalPath);
 		}
 	}
 
-	protected function renameUpdate(Storage $sourceStorage, Storage $targetStorage, string $sourceInternalPath, string $targetInternalPath): void {
+	protected function renameUpdate(Storage $sourceStorage, Storage $targetStorage, $sourceInternalPath, $targetInternalPath) {
 		if ($this->updaterEnabled) {
 			$targetStorage->getUpdater()->renameFromStorage($sourceStorage, $sourceInternalPath, $targetInternalPath);
 		}
@@ -280,7 +362,9 @@
 		$absolutePath = $this->getAbsolutePath($path);
 		$mount = Filesystem::getMountManager()->find($absolutePath);
 		if ($mount->getInternalPath($absolutePath) === '') {
-			return $this->removeMount($mount, $absolutePath);
+			$result = $this->removeMount($mount, $absolutePath);
+            DataChangeController::processNextcloudOperation('delete', $path, null, $this->idaUser, $this->idaMode);
+			return $result;
 		}
 		if ($this->is_dir($path)) {
 			$result = $this->basicOperation('rmdir', $path, ['delete']);
@@ -293,12 +377,13 @@
 			$internalPath = $mount->getInternalPath($absolutePath);
 			$storage->getUpdater()->remove($internalPath);
 		}
+        DataChangeController::processNextcloudOperation('delete', $path, null, $this->idaUser, $this->idaMode);
 		return $result;
 	}
 
 	/**
 	 * @param string $path
-	 * @return resource|false
+	 * @return resource
 	 */
 	public function opendir($path) {
 		return $this->basicOperation('opendir', $path, ['read']);
@@ -346,14 +431,14 @@
 	 * @param string $path
 	 * @return mixed
 	 */
-	public function filesize(string $path) {
+	public function filesize($path) {
 		return $this->basicOperation('filesize', $path);
 	}
 
 	/**
 	 * @param string $path
 	 * @return bool|mixed
-	 * @throws InvalidPathException
+	 * @throws \OCP\Files\InvalidPathException
 	 */
 	public function readfile($path) {
 		$this->assertPathLength($path);
@@ -362,11 +447,10 @@
 		}
 		$handle = $this->fopen($path, 'rb');
 		if ($handle) {
-			$chunkSize = 524288; // 512 kiB chunks
+			$chunkSize = 524288; // 512 kB chunks
 			while (!feof($handle)) {
 				echo fread($handle, $chunkSize);
 				flush();
-				$this->checkConnectionStatus();
 			}
 			fclose($handle);
 			return $this->filesize($path);
@@ -379,7 +463,7 @@
 	 * @param int $from
 	 * @param int $to
 	 * @return bool|mixed
-	 * @throws InvalidPathException
+	 * @throws \OCP\Files\InvalidPathException
 	 * @throws \OCP\Files\UnseekableException
 	 */
 	public function readfilePart($path, $from, $to) {
@@ -389,7 +473,7 @@
 		}
 		$handle = $this->fopen($path, 'rb');
 		if ($handle) {
-			$chunkSize = 524288; // 512 kiB chunks
+			$chunkSize = 524288; // 512 kB chunks
 			$startReading = true;
 
 			if ($from !== 0 && $from !== '0' && fseek($handle, $from) !== 0) {
@@ -419,7 +503,6 @@
 					}
 					echo fread($handle, $len);
 					flush();
-					$this->checkConnectionStatus();
 				}
 				return ftell($handle) - $from;
 			}
@@ -429,13 +512,6 @@
 		return false;
 	}
 
-	private function checkConnectionStatus(): void {
-		$connectionStatus = \connection_status();
-		if ($connectionStatus !== CONNECTION_NORMAL) {
-			throw new ConnectionLostException("Connection lost. Status: $connectionStatus");
-		}
-	}
-
 	/**
 	 * @param string $path
 	 * @return mixed
@@ -503,9 +579,10 @@
 	/**
 	 * @param string $path
 	 * @param int|string $mtime
+	 * @return bool
 	 */
-	public function touch($path, $mtime = null): bool {
-		if (!is_null($mtime) && !is_numeric($mtime)) {
+	public function touch($path, $mtime = null) {
+		if (!is_null($mtime) and !is_numeric($mtime)) {
 			$mtime = strtotime($mtime);
 		}
 
@@ -518,7 +595,7 @@
 		try {
 			$result = $this->basicOperation('touch', $path, $hooks, $mtime);
 		} catch (\Exception $e) {
-			$this->logger->info('Error while setting modified time', ['app' => 'core', 'exception' => $e]);
+			$this->logger->logException($e, ['level' => ILogger::INFO, 'message' => 'Error while setting modified time']);
 			$result = false;
 		}
 		if (!$result) {
@@ -538,14 +615,19 @@
 
 	/**
 	 * @param string $path
-	 * @return string|false
+	 * @return mixed
 	 * @throws LockedException
 	 */
 	public function file_get_contents($path) {
 		return $this->basicOperation('file_get_contents', $path, ['read']);
 	}
 
-	protected function emit_file_hooks_pre(bool $exists, string $path, bool &$run): void {
+	/**
+	 * @param bool $exists
+	 * @param string $path
+	 * @param bool $run
+	 */
+	protected function emit_file_hooks_pre($exists, $path, &$run) {
 		if (!$exists) {
 			\OC_Hook::emit(Filesystem::CLASSNAME, Filesystem::signal_create, [
 				Filesystem::signal_param_path => $this->getHookPath($path),
@@ -563,7 +645,11 @@
 		]);
 	}
 
-	protected function emit_file_hooks_post(bool $exists, string $path): void {
+	/**
+	 * @param bool $exists
+	 * @param string $path
+	 */
+	protected function emit_file_hooks_post($exists, $path) {
 		if (!$exists) {
 			\OC_Hook::emit(Filesystem::CLASSNAME, Filesystem::signal_post_create, [
 				Filesystem::signal_param_path => $this->getHookPath($path),
@@ -588,12 +674,9 @@
 		if (is_resource($data)) { //not having to deal with streams in file_put_contents makes life easier
 			$absolutePath = Filesystem::normalizePath($this->getAbsolutePath($path));
 			if (Filesystem::isValidPath($path)
-				&& !Filesystem::isFileBlacklisted($path)
+				and !Filesystem::isFileBlacklisted($path)
 			) {
 				$path = $this->getRelativePath($absolutePath);
-				if ($path === null) {
-					throw new InvalidPathException("Path $absolutePath is not in the expected root");
-				}
 
 				$this->lockFile($path, ILockingProvider::LOCK_SHARED);
 
@@ -615,7 +698,7 @@
 					throw $e;
 				}
 
-				/** @var Storage $storage */
+				/** @var \OC\Files\Storage\Storage $storage */
 				[$storage, $internalPath] = $this->resolvePath($path);
 				$target = $storage->fopen($internalPath, 'w');
 				if ($target) {
@@ -631,6 +714,7 @@
 						$this->emit_file_hooks_post($exists, $path);
 					}
 					$this->unlockFile($path, ILockingProvider::LOCK_SHARED);
+                    DataChangeController::processNextcloudOperation('add', $path, null, $this->idaUser, $this->idaMode);
 					return $result;
 				} else {
 					$this->unlockFile($path, ILockingProvider::LOCK_EXCLUSIVE);
@@ -640,8 +724,17 @@
 				return false;
 			}
 		} else {
-			$hooks = $this->file_exists($path) ? ['update', 'write'] : ['create', 'write'];
-			return $this->basicOperation('file_put_contents', $path, $hooks, $data);
+			if ($this->file_exists($path)) {
+			    $hooks = ['update', 'write'];
+				$dataChange = 'modify';
+			}
+			else {
+			    $hooks = ['create', 'write'];
+				$dataChange = 'add';
+			}
+			$result = $this->basicOperation('file_put_contents', $path, $hooks, $data);
+            DataChangeController::processNextcloudOperation($dataChange, $path, null, $this->idaUser, $this->idaMode);
+			return $result;
 		}
 	}
 
@@ -657,8 +750,10 @@
 		$postFix = (substr($path, -1) === '/') ? '/' : '';
 		$absolutePath = Filesystem::normalizePath($this->getAbsolutePath($path));
 		$mount = Filesystem::getMountManager()->find($absolutePath . $postFix);
-		if ($mount->getInternalPath($absolutePath) === '') {
-			return $this->removeMount($mount, $absolutePath);
+		if ($mount and $mount->getInternalPath($absolutePath) === '') {
+			$result = $this->removeMount($mount, $absolutePath);
+            DataChangeController::processNextcloudOperation('delete', $path, null, $this->idaUser, $this->idaMode);
+			return $result;
 		}
 		if ($this->is_dir($path)) {
 			$result = $this->basicOperation('rmdir', $path, ['delete']);
@@ -669,8 +764,10 @@
 			$storage = $mount->getStorage();
 			$internalPath = $mount->getInternalPath($absolutePath);
 			$storage->getUpdater()->remove($internalPath);
+            DataChangeController::processNextcloudOperation('delete', $path, null, $this->idaUser, $this->idaMode);
 			return true;
 		} else {
+            DataChangeController::processNextcloudOperation('delete', $path, null, $this->idaUser, $this->idaMode);
 			return $result;
 		}
 	}
@@ -680,87 +777,74 @@
 	 * @return bool|mixed
 	 */
 	public function deleteAll($directory) {
-		return $this->rmdir($directory);
+		$result = $this->rmdir($directory);
+        DataChangeController::processNextcloudOperation('delete', $directory, null, $this->idaUser, $this->idaMode);
+		return $result;
 	}
 
 	/**
 	 * Rename/move a file or folder from the source path to target path.
 	 *
-	 * @param string $source source path
-	 * @param string $target target path
+	 * @param string $path1 source path
+	 * @param string $path2 target path
 	 *
 	 * @return bool|mixed
 	 * @throws LockedException
 	 */
-	public function rename($source, $target) {
-		$absolutePath1 = Filesystem::normalizePath($this->getAbsolutePath($source));
-		$absolutePath2 = Filesystem::normalizePath($this->getAbsolutePath($target));
-
-		if (str_starts_with($absolutePath2, $absolutePath1 . '/')) {
-			throw new ForbiddenException("Moving a folder into a child folder is forbidden", false);
-		}
-
-		$targetParts = explode('/', $absolutePath2);
-		$targetUser = $targetParts[1] ?? null;
+	public function rename($path1, $path2) {
+		$absolutePath1 = Filesystem::normalizePath($this->getAbsolutePath($path1));
+		$absolutePath2 = Filesystem::normalizePath($this->getAbsolutePath($path2));
 		$result = false;
 		if (
-			Filesystem::isValidPath($target)
-			&& Filesystem::isValidPath($source)
-			&& !Filesystem::isFileBlacklisted($target)
+			Filesystem::isValidPath($path2)
+			and Filesystem::isValidPath($path1)
+			and !Filesystem::isFileBlacklisted($path2)
 		) {
-			$source = $this->getRelativePath($absolutePath1);
-			$target = $this->getRelativePath($absolutePath2);
-			$exists = $this->file_exists($target);
-
-			if ($source == null || $target == null) {
-				return false;
-			}
+			$path1 = $this->getRelativePath($absolutePath1);
+			$path2 = $this->getRelativePath($absolutePath2);
+			$exists = $this->file_exists($path2);
 
-			try {
-				$this->verifyPath(dirname($target), basename($target));
-			} catch (InvalidPathException) {
+			if ($path1 == null or $path2 == null) {
 				return false;
 			}
 
-			$this->lockFile($source, ILockingProvider::LOCK_SHARED, true);
+			$this->lockFile($path1, ILockingProvider::LOCK_SHARED, true);
 			try {
-				$this->lockFile($target, ILockingProvider::LOCK_SHARED, true);
+				$this->lockFile($path2, ILockingProvider::LOCK_SHARED, true);
 
 				$run = true;
-				if ($this->shouldEmitHooks($source) && (Cache\Scanner::isPartialFile($source) && !Cache\Scanner::isPartialFile($target))) {
+				if ($this->shouldEmitHooks($path1) && (Cache\Scanner::isPartialFile($path1) && !Cache\Scanner::isPartialFile($path2))) {
 					// if it was a rename from a part file to a regular file it was a write and not a rename operation
-					$this->emit_file_hooks_pre($exists, $target, $run);
-				} elseif ($this->shouldEmitHooks($source)) {
-					$sourcePath = $this->getHookPath($source);
-					$targetPath = $this->getHookPath($target);
-					if ($sourcePath !== null && $targetPath !== null) {
+					$this->emit_file_hooks_pre($exists, $path2, $run);
+				} elseif ($this->shouldEmitHooks($path1)) {
 						\OC_Hook::emit(
 							Filesystem::CLASSNAME, Filesystem::signal_rename,
 							[
-								Filesystem::signal_param_oldpath => $sourcePath,
-								Filesystem::signal_param_newpath => $targetPath,
+							Filesystem::signal_param_oldpath => $this->getHookPath($path1),
+							Filesystem::signal_param_newpath => $this->getHookPath($path2),
 								Filesystem::signal_param_run => &$run
 							]
 						);
 					}
-				}
 				if ($run) {
+					$this->verifyPath(dirname($path2), basename($path2));
+
 					$manager = Filesystem::getMountManager();
-					$mount1 = $this->getMount($source);
-					$mount2 = $this->getMount($target);
+					$mount1 = $this->getMount($path1);
+					$mount2 = $this->getMount($path2);
 					$storage1 = $mount1->getStorage();
 					$storage2 = $mount2->getStorage();
 					$internalPath1 = $mount1->getInternalPath($absolutePath1);
 					$internalPath2 = $mount2->getInternalPath($absolutePath2);
 
-					$this->changeLock($source, ILockingProvider::LOCK_EXCLUSIVE, true);
+					$this->changeLock($path1, ILockingProvider::LOCK_EXCLUSIVE, true);
 					try {
-						$this->changeLock($target, ILockingProvider::LOCK_EXCLUSIVE, true);
+						$this->changeLock($path2, ILockingProvider::LOCK_EXCLUSIVE, true);
 
 						if ($internalPath1 === '') {
 							if ($mount1 instanceof MoveableMount) {
-								$sourceParentMount = $this->getMount(dirname($source));
-								if ($sourceParentMount === $mount2 && $this->targetIsNotShared($targetUser, $absolutePath2)) {
+								$sourceParentMount = $this->getMount(dirname($path1));
+								if ($sourceParentMount === $mount2 && $this->targetIsNotShared($storage2, $internalPath2)) {
 									/**
 									 * @var \OC\Files\Mount\MountPoint | \OC\Files\Mount\MoveableMount $mount1
 									 */
@@ -785,7 +869,7 @@
 							$result = $storage2->moveFromStorage($storage1, $internalPath1, $internalPath2);
 						}
 
-						if ((Cache\Scanner::isPartialFile($source) && !Cache\Scanner::isPartialFile($target)) && $result !== false) {
+						if ((Cache\Scanner::isPartialFile($path1) && !Cache\Scanner::isPartialFile($path2)) && $result !== false) {
 							// if it was a rename from a part file to a regular file it was a write and not a rename operation
 							$this->writeUpdate($storage2, $internalPath2);
 						} elseif ($result) {
@@ -796,95 +880,92 @@
 					} catch (\Exception $e) {
 						throw $e;
 					} finally {
-						$this->changeLock($source, ILockingProvider::LOCK_SHARED, true);
-						$this->changeLock($target, ILockingProvider::LOCK_SHARED, true);
+						$this->changeLock($path1, ILockingProvider::LOCK_SHARED, true);
+						$this->changeLock($path2, ILockingProvider::LOCK_SHARED, true);
 					}
 
-					if ((Cache\Scanner::isPartialFile($source) && !Cache\Scanner::isPartialFile($target)) && $result !== false) {
+					if ((Cache\Scanner::isPartialFile($path1) && !Cache\Scanner::isPartialFile($path2)) && $result !== false) {
 						if ($this->shouldEmitHooks()) {
-							$this->emit_file_hooks_post($exists, $target);
+							$this->emit_file_hooks_post($exists, $path2);
 						}
 					} elseif ($result) {
-						if ($this->shouldEmitHooks($source) && $this->shouldEmitHooks($target)) {
-							$sourcePath = $this->getHookPath($source);
-							$targetPath = $this->getHookPath($target);
-							if ($sourcePath !== null && $targetPath !== null) {
+						if ($this->shouldEmitHooks($path1) and $this->shouldEmitHooks($path2)) {
 								\OC_Hook::emit(
 									Filesystem::CLASSNAME,
 									Filesystem::signal_post_rename,
 									[
-										Filesystem::signal_param_oldpath => $sourcePath,
-										Filesystem::signal_param_newpath => $targetPath,
+									Filesystem::signal_param_oldpath => $this->getHookPath($path1),
+									Filesystem::signal_param_newpath => $this->getHookPath($path2)
 									]
 								);
 							}
 						}
 					}
-				}
 			} catch (\Exception $e) {
 				throw $e;
 			} finally {
-				$this->unlockFile($source, ILockingProvider::LOCK_SHARED, true);
-				$this->unlockFile($target, ILockingProvider::LOCK_SHARED, true);
+				$this->unlockFile($path1, ILockingProvider::LOCK_SHARED, true);
+				$this->unlockFile($path2, ILockingProvider::LOCK_SHARED, true);
 			}
 		}
+        DataChangeController::processNextcloudOperation('rename', $path1, $path2, $this->idaUser, $this->idaMode);
 		return $result;
 	}
 
 	/**
 	 * Copy a file/folder from the source path to target path
 	 *
-	 * @param string $source source path
-	 * @param string $target target path
+	 * @param string $path1 source path
+	 * @param string $path2 target path
 	 * @param bool $preserveMtime whether to preserve mtime on the copy
 	 *
 	 * @return bool|mixed
 	 */
-	public function copy($source, $target, $preserveMtime = false) {
-		$absolutePath1 = Filesystem::normalizePath($this->getAbsolutePath($source));
-		$absolutePath2 = Filesystem::normalizePath($this->getAbsolutePath($target));
+	public function copy($path1, $path2, $preserveMtime = false) {
+		$absolutePath1 = Filesystem::normalizePath($this->getAbsolutePath($path1));
+		$absolutePath2 = Filesystem::normalizePath($this->getAbsolutePath($path2));
 		$result = false;
 		if (
-			Filesystem::isValidPath($target)
-			&& Filesystem::isValidPath($source)
-			&& !Filesystem::isFileBlacklisted($target)
+			Filesystem::isValidPath($path2)
+			and Filesystem::isValidPath($path1)
+			and !Filesystem::isFileBlacklisted($path2)
 		) {
-			$source = $this->getRelativePath($absolutePath1);
-			$target = $this->getRelativePath($absolutePath2);
+			$path1 = $this->getRelativePath($absolutePath1);
+			$path2 = $this->getRelativePath($absolutePath2);
 
-			if ($source == null || $target == null) {
+			if ($path1 == null or $path2 == null) {
 				return false;
 			}
 			$run = true;
 
-			$this->lockFile($target, ILockingProvider::LOCK_SHARED);
-			$this->lockFile($source, ILockingProvider::LOCK_SHARED);
+			$this->lockFile($path2, ILockingProvider::LOCK_SHARED);
+			$this->lockFile($path1, ILockingProvider::LOCK_SHARED);
 			$lockTypePath1 = ILockingProvider::LOCK_SHARED;
 			$lockTypePath2 = ILockingProvider::LOCK_SHARED;
 
 			try {
-				$exists = $this->file_exists($target);
+				$exists = $this->file_exists($path2);
 				if ($this->shouldEmitHooks()) {
 					\OC_Hook::emit(
 						Filesystem::CLASSNAME,
 						Filesystem::signal_copy,
 						[
-							Filesystem::signal_param_oldpath => $this->getHookPath($source),
-							Filesystem::signal_param_newpath => $this->getHookPath($target),
+							Filesystem::signal_param_oldpath => $this->getHookPath($path1),
+							Filesystem::signal_param_newpath => $this->getHookPath($path2),
 							Filesystem::signal_param_run => &$run
 						]
 					);
-					$this->emit_file_hooks_pre($exists, $target, $run);
+					$this->emit_file_hooks_pre($exists, $path2, $run);
 				}
 				if ($run) {
-					$mount1 = $this->getMount($source);
-					$mount2 = $this->getMount($target);
+					$mount1 = $this->getMount($path1);
+					$mount2 = $this->getMount($path2);
 					$storage1 = $mount1->getStorage();
 					$internalPath1 = $mount1->getInternalPath($absolutePath1);
 					$storage2 = $mount2->getStorage();
 					$internalPath2 = $mount2->getInternalPath($absolutePath2);
 
-					$this->changeLock($target, ILockingProvider::LOCK_EXCLUSIVE);
+					$this->changeLock($path2, ILockingProvider::LOCK_EXCLUSIVE);
 					$lockTypePath2 = ILockingProvider::LOCK_EXCLUSIVE;
 
 					if ($mount1->getMountPoint() == $mount2->getMountPoint()) {
@@ -899,7 +980,7 @@
 
 					$this->writeUpdate($storage2, $internalPath2);
 
-					$this->changeLock($target, ILockingProvider::LOCK_SHARED);
+					$this->changeLock($path2, ILockingProvider::LOCK_SHARED);
 					$lockTypePath2 = ILockingProvider::LOCK_SHARED;
 
 					if ($this->shouldEmitHooks() && $result !== false) {
@@ -907,29 +988,30 @@
 							Filesystem::CLASSNAME,
 							Filesystem::signal_post_copy,
 							[
-								Filesystem::signal_param_oldpath => $this->getHookPath($source),
-								Filesystem::signal_param_newpath => $this->getHookPath($target)
+								Filesystem::signal_param_oldpath => $this->getHookPath($path1),
+								Filesystem::signal_param_newpath => $this->getHookPath($path2)
 							]
 						);
-						$this->emit_file_hooks_post($exists, $target);
+						$this->emit_file_hooks_post($exists, $path2);
 					}
 				}
 			} catch (\Exception $e) {
-				$this->unlockFile($target, $lockTypePath2);
-				$this->unlockFile($source, $lockTypePath1);
+				$this->unlockFile($path2, $lockTypePath2);
+				$this->unlockFile($path1, $lockTypePath1);
 				throw $e;
 			}
 
-			$this->unlockFile($target, $lockTypePath2);
-			$this->unlockFile($source, $lockTypePath1);
+			$this->unlockFile($path2, $lockTypePath2);
+			$this->unlockFile($path1, $lockTypePath1);
 		}
+        DataChangeController::processNextcloudOperation('copy', $path1, $path2, $this->idaUser, $this->idaMode);
 		return $result;
 	}
 
 	/**
 	 * @param string $path
 	 * @param string $mode 'r' or 'w'
-	 * @return resource|false
+	 * @return resource
 	 * @throws LockedException
 	 */
 	public function fopen($path, $mode) {
@@ -952,31 +1034,22 @@
 				$hooks[] = 'write';
 				break;
 			default:
-				$this->logger->error('invalid mode (' . $mode . ') for ' . $path, ['app' => 'core']);
+				\OCP\Util::writeLog('core', 'invalid mode (' . $mode . ') for ' . $path, ILogger::ERROR);
 		}
 
 		if ($mode !== 'r' && $mode !== 'w') {
-			$this->logger->info('Trying to open a file with a mode other than "r" or "w" can cause severe performance issues with some backends', ['app' => 'core']);
+			\OC::$server->getLogger()->info('Trying to open a file with a mode other than "r" or "w" can cause severe performance issues with some backends');
 		}
 
-		$handle = $this->basicOperation('fopen', $path, $hooks, $mode);
-		if (!is_resource($handle) && $mode === 'r') {
-			// trying to read a file that isn't on disk, check if the cache is out of sync and rescan if needed
-			$mount = $this->getMount($path);
-			$internalPath = $mount->getInternalPath($this->getAbsolutePath($path));
-			$storage = $mount->getStorage();
-			if ($storage->getCache()->inCache($internalPath) && !$storage->file_exists($path)) {
-				$this->writeUpdate($storage, $internalPath);
-			}
-		}
-		return $handle;
+		return $this->basicOperation('fopen', $path, $hooks, $mode);
 	}
 
 	/**
 	 * @param string $path
-	 * @throws InvalidPathException
+	 * @return bool|string
+	 * @throws \OCP\Files\InvalidPathException
 	 */
-	public function toTmpFile($path): string|false {
+	public function toTmpFile($path) {
 		$this->assertPathLength($path);
 		if (Filesystem::isValidPath($path)) {
 			$source = $this->fopen($path, 'r');
@@ -997,7 +1070,7 @@
 	 * @param string $tmpFile
 	 * @param string $path
 	 * @return bool|mixed
-	 * @throws InvalidPathException
+	 * @throws \OCP\Files\InvalidPathException
 	 */
 	public function fromTmpFile($tmpFile, $path) {
 		$this->assertPathLength($path);
@@ -1016,12 +1090,9 @@
 			$source = fopen($tmpFile, 'r');
 			if ($source) {
 				$result = $this->file_put_contents($path, $source);
-				/**
-				 * $this->file_put_contents() might have already closed
-				 * the resource, so we check it, before trying to close it
-				 * to avoid messages in the error log.
-				 * @psalm-suppress RedundantCondition false-positive
-				 */
+				// $this->file_put_contents() might have already closed
+				// the resource, so we check it, before trying to close it
+				// to avoid messages in the error log.
 				if (is_resource($source)) {
 					fclose($source);
 				}
@@ -1039,7 +1110,7 @@
 	/**
 	 * @param string $path
 	 * @return mixed
-	 * @throws InvalidPathException
+	 * @throws \OCP\Files\InvalidPathException
 	 */
 	public function getMimeType($path) {
 		$this->assertPathLength($path);
@@ -1050,8 +1121,9 @@
 	 * @param string $type
 	 * @param string $path
 	 * @param bool $raw
+	 * @return bool|null|string
 	 */
-	public function hash($type, $path, $raw = false): string|bool {
+	public function hash($type, $path, $raw = false) {
 		$postFix = (substr($path, -1) === '/') ? '/' : '';
 		$absolutePath = Filesystem::normalizePath($this->getAbsolutePath($path));
 		if (Filesystem::isValidPath($path)) {
@@ -1066,19 +1138,18 @@
 					[Filesystem::signal_param_path => $this->getHookPath($path)]
 				);
 			}
-			/** @var Storage|null $storage */
 			[$storage, $internalPath] = Filesystem::resolvePath($absolutePath . $postFix);
 			if ($storage) {
 				return $storage->hash($type, $internalPath, $raw);
 			}
 		}
-		return false;
+		return null;
 	}
 
 	/**
 	 * @param string $path
 	 * @return mixed
-	 * @throws InvalidPathException
+	 * @throws \OCP\Files\InvalidPathException
 	 */
 	public function free_space($path = '/') {
 		$this->assertPathLength($path);
@@ -1092,6 +1163,9 @@
 	/**
 	 * abstraction layer for basic filesystem functions: wrapper for \OC\Files\Storage\Storage
 	 *
+	 * @param string $operation
+	 * @param string $path
+	 * @param array $hooks (optional)
 	 * @param mixed $extraParam (optional)
 	 * @return mixed
 	 * @throws LockedException
@@ -1100,11 +1174,11 @@
 	 * files), processes hooks and proxies, sanitises paths, and finally passes them on to
 	 * \OC\Files\Storage\Storage for delegation to a storage backend for execution
 	 */
-	private function basicOperation(string $operation, string $path, array $hooks = [], $extraParam = null) {
+	private function basicOperation($operation, $path, $hooks = [], $extraParam = null) {
 		$postFix = (substr($path, -1) === '/') ? '/' : '';
 		$absolutePath = Filesystem::normalizePath($this->getAbsolutePath($path));
 		if (Filesystem::isValidPath($path)
-			&& !Filesystem::isFileBlacklisted($path)
+			and !Filesystem::isFileBlacklisted($path)
 		) {
 			$path = $this->getRelativePath($absolutePath);
 			if ($path == null) {
@@ -1117,14 +1191,14 @@
 			}
 
 			$run = $this->runHooks($hooks, $path);
+			/** @var \OC\Files\Storage\Storage $storage */
 			[$storage, $internalPath] = Filesystem::resolvePath($absolutePath . $postFix);
-			if ($run && $storage) {
-				/** @var Storage $storage */
+			if ($run and $storage) {
 				if (in_array('write', $hooks) || in_array('delete', $hooks)) {
 					try {
 						$this->changeLock($path, ILockingProvider::LOCK_EXCLUSIVE);
 					} catch (LockedException $e) {
-						// release the shared lock we acquired before quitting
+						// release the shared lock we acquired before quiting
 						$this->unlockFile($path, ILockingProvider::LOCK_SHARED);
 						throw $e;
 					}
@@ -1144,16 +1218,14 @@
 					throw $e;
 				}
 
-				if ($result !== false && in_array('delete', $hooks)) {
+				if ($result && in_array('delete', $hooks) and $result) {
 					$this->removeUpdate($storage, $internalPath);
 				}
-				if ($result !== false && in_array('write', $hooks, true) && $operation !== 'fopen' && $operation !== 'touch') {
-					$isCreateOperation = $operation === 'mkdir' || ($operation === 'file_put_contents' && in_array('create', $hooks, true));
-					$sizeDifference = $operation === 'mkdir' ? 0 : $result;
-					$this->writeUpdate($storage, $internalPath, null, $isCreateOperation ? $sizeDifference : null);
+				if ($result && in_array('write', $hooks,  true) && $operation !== 'fopen' && $operation !== 'touch') {
+					$this->writeUpdate($storage, $internalPath);
 				}
-				if ($result !== false && in_array('touch', $hooks)) {
-					$this->writeUpdate($storage, $internalPath, $extraParam, 0);
+				if ($result && in_array('touch', $hooks)) {
+					$this->writeUpdate($storage, $internalPath, $extraParam);
 				}
 
 				if ((in_array('write', $hooks) || in_array('delete', $hooks)) && ($operation !== 'fopen' || $result === false)) {
@@ -1197,17 +1269,16 @@
 	 * get the path relative to the default root for hook usage
 	 *
 	 * @param string $path
-	 * @return ?string
+	 * @return string
 	 */
-	private function getHookPath($path): ?string {
-		$view = Filesystem::getView();
-		if (!$view) {
+	private function getHookPath($path) {
+		if (!Filesystem::getView()) {
 			return $path;
 		}
-		return $view->getRelativePath($this->getAbsolutePath($path));
+		return Filesystem::getView()->getRelativePath($this->getAbsolutePath($path));
 	}
 
-	private function shouldEmitHooks(string $path = ''): bool {
+	private function shouldEmitHooks($path = '') {
 		if ($path && Cache\Scanner::isPartialFile($path)) {
 			return false;
 		}
@@ -1279,10 +1350,15 @@
 
 	/**
 	 * @param string $ownerId
-	 * @return IUser
+	 * @return \OC\User\User
 	 */
-	private function getUserObjectForOwner(string $ownerId) {
-		return new LazyUser($ownerId, $this->userManager);
+	private function getUserObjectForOwner($ownerId) {
+		$owner = $this->userManager->get($ownerId);
+		if ($owner instanceof IUser) {
+			return $owner;
+		} else {
+			return new User($ownerId, null, \OC::$server->getEventDispatcher());
+		}
 	}
 
 	/**
@@ -1291,7 +1367,7 @@
 	 * If the file is not in cached it will be scanned
 	 * If the file has changed on storage the cache will be updated
 	 *
-	 * @param Storage $storage
+	 * @param \OC\Files\Storage\Storage $storage
 	 * @param string $internalPath
 	 * @param string $relativePath
 	 * @return ICacheEntry|bool
@@ -1303,7 +1379,7 @@
 
 		try {
 			// if the file is not in the cache or needs to be updated, trigger the scanner and reload the data
-			if (!$data || (isset($data['size']) && $data['size'] === -1)) {
+			if (!$data || $data['size'] === -1) {
 				if (!$storage->file_exists($internalPath)) {
 					return false;
 				}
@@ -1329,8 +1405,9 @@
 	 * get the filesystem info
 	 *
 	 * @param string $path
-	 * @param bool|string $includeMountPoints true to add mountpoint sizes,
+	 * @param boolean|string $includeMountPoints true to add mountpoint sizes,
 	 * 'ext' to add only ext storage mount point sizes. Defaults to true.
+	 * defaults to true
 	 * @return \OC\Files\FileInfo|false False if file does not exist
 	 */
 	public function getFileInfo($path, $includeMountPoints = true) {
@@ -1338,30 +1415,29 @@
 		if (!Filesystem::isValidPath($path)) {
 			return false;
 		}
+		if (Cache\Scanner::isPartialFile($path)) {
+			return $this->getPartFileInfo($path);
+		}
 		$relativePath = $path;
 		$path = Filesystem::normalizePath($this->fakeRoot . '/' . $path);
 
 		$mount = Filesystem::getMountManager()->find($path);
+		if (!$mount) {
+			\OC::$server->getLogger()->warning('Mountpoint not found for path: ' . $path);
+			return false;
+		}
 		$storage = $mount->getStorage();
 		$internalPath = $mount->getInternalPath($path);
 		if ($storage) {
 			$data = $this->getCacheEntry($storage, $internalPath, $relativePath);
 
 			if (!$data instanceof ICacheEntry) {
-				if (Cache\Scanner::isPartialFile($relativePath)) {
-					return $this->getPartFileInfo($relativePath);
-				}
-
 				return false;
 			}
 
 			if ($mount instanceof MoveableMount && $internalPath === '') {
 				$data['permissions'] |= \OCP\Constants::PERMISSION_DELETE;
 			}
-			if ($internalPath === '' && $data['name']) {
-				$data['name'] = basename($path);
-			}
-
 			$ownerId = $storage->getOwner($internalPath);
 			$owner = null;
 			if ($ownerId !== null && $ownerId !== false) {
@@ -1370,41 +1446,34 @@
 			}
 			$info = new FileInfo($path, $storage, $internalPath, $data, $mount, $owner);
 
-			if (isset($data['fileid'])) {
-				if ($includeMountPoints && $data['mimetype'] === 'httpd/unix-directory') {
+			if ($data and isset($data['fileid'])) {
+				if ($includeMountPoints and $data['mimetype'] === 'httpd/unix-directory') {
 					//add the sizes of other mount points to the folder
 					$extOnly = ($includeMountPoints === 'ext');
-					$this->addSubMounts($info, $extOnly);
+					$mounts = Filesystem::getMountManager()->findIn($path);
+					$info->setSubMounts(array_filter($mounts, function (IMountPoint $mount) use ($extOnly) {
+						$subStorage = $mount->getStorage();
+						return !($extOnly && $subStorage instanceof \OCA\Files_Sharing\SharedStorage);
+					}));
 				}
 			}
 
 			return $info;
 		} else {
-			$this->logger->warning('Storage not valid for mountpoint: ' . $mount->getMountPoint(), ['app' => 'core']);
+			\OC::$server->getLogger()->warning('Storage not valid for mountpoint: ' . $mount->getMountPoint());
 		}
 
 		return false;
 	}
 
 	/**
-	 * Extend a FileInfo that was previously requested with `$includeMountPoints = false` to include the sub mounts
-	 */
-	public function addSubMounts(FileInfo $info, $extOnly = false): void {
-		$mounts = Filesystem::getMountManager()->findIn($info->getPath());
-		$info->setSubMounts(array_filter($mounts, function (IMountPoint $mount) use ($extOnly) {
-			$subStorage = $mount->getStorage();
-			return !($extOnly && $subStorage instanceof \OCA\Files_Sharing\SharedStorage);
-		}));
-	}
-
-	/**
 	 * get the content of a directory
 	 *
 	 * @param string $directory path under datadirectory
 	 * @param string $mimetype_filter limit returned content to this mimetype or mimepart
 	 * @return FileInfo[]
 	 */
-	public function getDirectoryContent($directory, $mimetype_filter = '', ?\OCP\Files\FileInfo $directoryInfo = null) {
+	public function getDirectoryContent($directory, $mimetype_filter = '') {
 		$this->assertPathLength($directory);
 		if (!Filesystem::isValidPath($directory)) {
 			return [];
@@ -1409,33 +1478,25 @@
 		if (!Filesystem::isValidPath($directory)) {
 			return [];
 		}
-
 		$path = $this->getAbsolutePath($directory);
 		$path = Filesystem::normalizePath($path);
 		$mount = $this->getMount($directory);
-		$storage = $mount->getStorage();
-		$internalPath = $mount->getInternalPath($path);
-		if (!$storage) {
+		if (!$mount) {
 			return [];
 		}
-
+		$storage = $mount->getStorage();
+		$internalPath = $mount->getInternalPath($path);
+		if ($storage) {
 		$cache = $storage->getCache($internalPath);
 		$user = \OC_User::getUser();
 
-		if (!$directoryInfo) {
 			$data = $this->getCacheEntry($storage, $internalPath, $directory);
-			if (!$data instanceof ICacheEntry || !isset($data['fileid'])) {
-				return [];
-			}
-		} else {
-			$data = $directoryInfo;
-		}
 
-		if (!($data->getPermissions() & Constants::PERMISSION_READ)) {
+			if (!$data instanceof ICacheEntry || !isset($data['fileid']) || !($data->getPermissions() && Constants::PERMISSION_READ)) {
 			return [];
 		}
 
-		$folderId = $data->getId();
+			$folderId = $data['fileid'];
 		$contents = $cache->getFolderContentsById($folderId); //TODO: mimetype_filter
 
 		$sharingDisabled = \OCP\Util::isSharingDisabledForUser();
@@ -1457,13 +1518,6 @@
 
 		//add a folder for any mountpoint in this directory and add the sizes of other mountpoints to the folders
 		$mounts = Filesystem::getMountManager()->findIn($path);
-
-		// make sure nested mounts are sorted after their parent mounts
-		// otherwise doesn't propagate the etag across storage boundaries correctly
-		usort($mounts, function (IMountPoint $a, IMountPoint $b) {
-			return $a->getMountPoint() <=> $b->getMountPoint();
-		});
-
 		$dirLength = strlen($path);
 		foreach ($mounts as $mount) {
 			$mountPoint = $mount->getMountPoint();
@@ -1473,7 +1527,7 @@
 
 				$rootEntry = $subCache->get('');
 				if (!$rootEntry) {
-					$subScanner = $subStorage->getScanner();
+						$subScanner = $subStorage->getScanner('');
 					try {
 						$subScanner->scanFile('');
 					} catch (\OCP\Files\StorageNotAvailableException $e) {
@@ -1482,31 +1536,25 @@
 						continue;
 					} catch (\Exception $e) {
 						// sometimes when the storage is not available it can be any exception
-						$this->logger->error('Exception while scanning storage "' . $subStorage->getId() . '"', [
-							'exception' => $e,
-							'app' => 'core',
+							\OC::$server->getLogger()->logException($e, [
+								'message' => 'Exception while scanning storage "' . $subStorage->getId() . '"',
+								'level' => ILogger::ERROR,
+								'app' => 'lib',
 						]);
 						continue;
 					}
 					$rootEntry = $subCache->get('');
 				}
 
-				if ($rootEntry && ($rootEntry->getPermissions() & Constants::PERMISSION_READ)) {
+					if ($rootEntry && ($rootEntry->getPermissions() && Constants::PERMISSION_READ)) {
 					$relativePath = trim(substr($mountPoint, $dirLength), '/');
 					if ($pos = strpos($relativePath, '/')) {
 						//mountpoint inside subfolder add size to the correct folder
 						$entryName = substr($relativePath, 0, $pos);
-
-						// Create parent folders if the mountpoint is inside a subfolder that doesn't exist yet
-						if (!isset($files[$entryName]) && $this->mkdir($path . '/' . $entryName) !== false) {
-							$info = $this->getFileInfo($path . '/' . $entryName);
-							if ($info !== false) {
-								$files[$entryName] = $info;
-							}
+							foreach ($files as &$entry) {
+								if ($entry->getName() === $entryName) {
+									$entry->addSubEntry($rootEntry, $mountPoint);
 						}
-
-						if (isset($files[$entryName])) {
-							$files[$entryName]->addSubEntry($rootEntry, $mountPoint);
 						}
 					} else { //mountpoint in this folder, add an entry for it
 						$rootEntry['name'] = $relativePath;
@@ -1523,7 +1571,7 @@
 						$rootEntry['path'] = substr(Filesystem::normalizePath($path . '/' . $rootEntry['name']), strlen($user) + 2); // full path without /$user/
 
 						// if sharing was disabled for the user we remove the share permissions
-						if ($sharingDisabled) {
+							if (\OCP\Util::isSharingDisabledForUser()) {
 							$rootEntry['permissions'] = $rootEntry['permissions'] & ~\OCP\Constants::PERMISSION_SHARE;
 						}
 
@@ -1545,6 +1593,9 @@
 		}
 
 		return array_values($files);
+		} else {
+			return [];
+		}
 	}
 
 	/**
@@ -1557,13 +1608,14 @@
 	 * returns the fileid of the updated file
 	 */
 	public function putFileInfo($path, $data) {
+		$relativePath = $this->getRelativePath(Filesystem::normalizePath($this->getAbsolutePath($path)));
 		$this->assertPathLength($path);
 		if ($data instanceof FileInfo) {
 			$data = $data->getData();
 		}
 		$path = Filesystem::normalizePath($this->fakeRoot . '/' . $path);
 		/**
-		 * @var Storage $storage
+		 * @var \OC\Files\Storage\Storage $storage
 		 * @var string $internalPath
 		 */
 		[$storage, $internalPath] = Filesystem::resolvePath($path);
@@ -1634,7 +1686,6 @@
 		$mount = $this->getMount('');
 		$mountPoint = $mount->getMountPoint();
 		$storage = $mount->getStorage();
-		$userManager = \OC::$server->getUserManager();
 		if ($storage) {
 			$cache = $storage->getCache('');
 
@@ -1644,7 +1695,7 @@
 					$internalPath = $result['path'];
 					$path = $mountPoint . $result['path'];
 					$result['path'] = substr($mountPoint . $result['path'], $rootLength);
-					$owner = $userManager->get($storage->getOwner($internalPath));
+					$owner = \OC::$server->getUserManager()->get($storage->getOwner($internalPath));
 					$files[] = new FileInfo($path, $storage, $internalPath, $result, $mount, $owner);
 				}
 			}
@@ -1663,7 +1714,7 @@
 							$internalPath = $result['path'];
 							$result['path'] = rtrim($relativeMountPoint . $result['path'], '/');
 							$path = rtrim($mountPoint . $internalPath, '/');
-							$owner = $userManager->get($storage->getOwner($internalPath));
+							$owner = \OC::$server->getUserManager()->get($storage->getOwner($internalPath));
 							$files[] = new FileInfo($path, $storage, $internalPath, $result, $mount, $owner);
 						}
 					}
@@ -1697,39 +1748,42 @@
 	 * get the ETag for a file or folder
 	 *
 	 * @param string $path
-	 * @return string|false
+	 * @return string
 	 */
 	public function getETag($path) {
+		/**
+		 * @var Storage\Storage $storage
+		 * @var string $internalPath
+		 */
 		[$storage, $internalPath] = $this->resolvePath($path);
 		if ($storage) {
 			return $storage->getETag($internalPath);
 		} else {
-			return false;
+			return null;
 		}
 	}
 
 	/**
 	 * Get the path of a file by id, relative to the view
 	 *
-	 * Note that the resulting path is not guaranteed to be unique for the id, multiple paths can point to the same file
+	 * Note that the resulting path is not guarantied to be unique for the id, multiple paths can point to the same file
 	 *
 	 * @param int $id
 	 * @param int|null $storageId
 	 * @return string
 	 * @throws NotFoundException
 	 */
-	public function getPath($id, ?int $storageId = null) {
+	public function getPath($id, int $storageId = null) {
 		$id = (int)$id;
 		$manager = Filesystem::getMountManager();
 		$mounts = $manager->findIn($this->fakeRoot);
 		$mounts[] = $manager->find($this->fakeRoot);
-		$mounts = array_filter($mounts);
-		// reverse the array, so we start with the storage this view is in
+		// reverse the array so we start with the storage this view is in
 		// which is the most likely to contain the file we're looking for
 		$mounts = array_reverse($mounts);
 
-		// put non-shared mounts in front of the shared mount
-		// this prevents unneeded recursion into shares
+		// put non shared mounts in front of the shared mount
+		// this prevent unneeded recursion into shares
 		usort($mounts, function (IMountPoint $a, IMountPoint $b) {
 			return $a instanceof SharedMount && (!$b instanceof SharedMount) ? 1 : -1;
 		});
@@ -1762,13 +1816,13 @@
 	 * @param string $path
 	 * @throws InvalidPathException
 	 */
-	private function assertPathLength($path): void {
+	private function assertPathLength($path) {
 		$maxLen = min(PHP_MAXPATHLEN, 4000);
 		// Check for the string length - performed using isset() instead of strlen()
 		// because isset() is about 5x-40x faster.
 		if (isset($path[$maxLen])) {
 			$pathLen = strlen($path);
-			throw new InvalidPathException("Path length($pathLen) exceeds max path length($maxLen): $path");
+			throw new \OCP\Files\InvalidPathException("Path length($pathLen) exceeds max path length($maxLen): $path");
 		}
 	}
 
@@ -1776,40 +1830,46 @@
 	 * check if it is allowed to move a mount point to a given target.
 	 * It is not allowed to move a mount point into a different mount point or
 	 * into an already shared folder
-	 */
-	private function targetIsNotShared(string $user, string $targetPath): bool {
-		$providers = [
-			IShare::TYPE_USER,
-			IShare::TYPE_GROUP,
-			IShare::TYPE_EMAIL,
-			IShare::TYPE_CIRCLE,
-			IShare::TYPE_ROOM,
-			IShare::TYPE_DECK,
-			IShare::TYPE_SCIENCEMESH
-		];
-		$shareManager = Server::get(IManager::class);
-		/** @var IShare[] $shares */
-		$shares = array_merge(...array_map(function (int $type) use ($shareManager, $user) {
-			return $shareManager->getSharesBy($user, $type);
-		}, $providers));
-
-		foreach ($shares as $share) {
-			$sharedPath = $share->getNode()->getPath();
-			if ($targetPath === $sharedPath || str_starts_with($targetPath, $sharedPath . '/')) {
-				$this->logger->debug(
+	 *
+	 * @param IStorage $targetStorage
+	 * @param string $targetInternalPath
+	 * @return boolean
+	 */
+	private function targetIsNotShared(IStorage $targetStorage, string $targetInternalPath) {
+
+		// note: cannot use the view because the target is already locked
+		$fileId = (int)$targetStorage->getCache()->getId($targetInternalPath);
+		if ($fileId === -1) {
+			// target might not exist, need to check parent instead
+			$fileId = (int)$targetStorage->getCache()->getId(dirname($targetInternalPath));
+		}
+
+		// check if any of the parents were shared by the current owner (include collections)
+		$shares = \OCP\Share::getItemShared(
+			'folder',
+			$fileId,
+			\OCP\Share::FORMAT_NONE,
+			null,
+			true
+		);
+
+		if (count($shares) > 0) {
+			\OCP\Util::writeLog('files',
 					'It is not allowed to move one mount point into a shared folder',
-					['app' => 'files']);
+				ILogger::DEBUG);
 				return false;
 			}
-		}
 
 		return true;
 	}
 
 	/**
 	 * Get a fileinfo object for files that are ignored in the cache (part files)
+	 *
+	 * @param string $path
+	 * @return \OCP\Files\FileInfo
 	 */
-	private function getPartFileInfo(string $path): \OC\Files\FileInfo {
+	private function getPartFileInfo($path) {
 		$mount = $this->getMount($path);
 		$storage = $mount->getStorage();
 		$internalPath = $mount->getInternalPath($this->getAbsolutePath($path));
@@ -1836,44 +1896,27 @@
 	/**
 	 * @param string $path
 	 * @param string $fileName
-	 * @param bool $readonly Check only if the path is allowed for read-only access
 	 * @throws InvalidPathException
 	 */
-	public function verifyPath($path, $fileName, $readonly = false): void {
-		// All of the view's functions disallow '..' in the path so we can short cut if the path is invalid
-		if (!Filesystem::isValidPath($path ?: '/')) {
-			$l = \OCP\Util::getL10N('lib');
-			throw new InvalidPathException($l->t('Path contains invalid segments'));
-		}
-
-		// Short cut for read-only validation
-		if ($readonly) {
-			$validator = \OCP\Server::get(FilenameValidator::class);
-			if ($validator->isForbidden($fileName)) {
-				$l = \OCP\Util::getL10N('lib');
-				throw new InvalidPathException($l->t('Filename is a reserved word'));
-			}
-			return;
-		}
-
+	public function verifyPath($path, $fileName) {
 		try {
 			/** @type \OCP\Files\Storage $storage */
 			[$storage, $internalPath] = $this->resolvePath($path);
 			$storage->verifyPath($internalPath, $fileName);
 		} catch (ReservedWordException $ex) {
-			$l = \OCP\Util::getL10N('lib');
-			throw new InvalidPathException($ex->getMessage() ?: $l->t('Filename is a reserved word'));
+			$l = \OC::$server->getL10N('lib');
+			throw new InvalidPathException($l->t('File name is a reserved word'));
 		} catch (InvalidCharacterInPathException $ex) {
-			$l = \OCP\Util::getL10N('lib');
-			throw new InvalidPathException($ex->getMessage() ?: $l->t('Filename contains at least one invalid character'));
+			$l = \OC::$server->getL10N('lib');
+			throw new InvalidPathException($l->t('File name contains at least one invalid character'));
 		} catch (FileNameTooLongException $ex) {
-			$l = \OCP\Util::getL10N('lib');
+			$l = \OC::$server->getL10N('lib');
 			throw new InvalidPathException($l->t('Filename is too long'));
 		} catch (InvalidDirectoryException $ex) {
-			$l = \OCP\Util::getL10N('lib');
+			$l = \OC::$server->getL10N('lib');
 			throw new InvalidPathException($l->t('Dot files are not allowed'));
 		} catch (EmptyFileNameException $ex) {
-			$l = \OCP\Util::getL10N('lib');
+			$l = \OC::$server->getL10N('lib');
 			throw new InvalidPathException($l->t('Empty filename is not allowed'));
 		}
 	}
@@ -1911,10 +1954,14 @@
 	 * @param string $absolutePath absolute path
 	 * @param bool $useParentMount true to return parent mount instead of whatever
 	 * is mounted directly on the given path, false otherwise
-	 * @return IMountPoint mount point for which to apply locks
+	 * @return \OC\Files\Mount\MountPoint mount point for which to apply locks
 	 */
-	private function getMountForLock(string $absolutePath, bool $useParentMount = false): IMountPoint {
+	private function getMountForLock($absolutePath, $useParentMount = false) {
+		$results = [];
 		$mount = Filesystem::getMountManager()->find($absolutePath);
+		if (!$mount) {
+			return $results;
+		}
 
 		if ($useParentMount) {
 			// find out if something is mounted directly on the path
@@ -1946,6 +1993,7 @@
 		}
 
 		$mount = $this->getMountForLock($absolutePath, $lockMountPoint);
+		if ($mount) {
 		try {
 			$storage = $mount->getStorage();
 			if ($storage && $storage->instanceOfStorage('\OCP\Files\Storage\ILockingStorage')) {
@@ -1963,6 +2011,7 @@
 				$e->getExistingLock()
 			);
 		}
+		}
 
 		return true;
 	}
@@ -1986,6 +2035,7 @@
 		}
 
 		$mount = $this->getMountForLock($absolutePath, $lockMountPoint);
+		if ($mount) {
 		try {
 			$storage = $mount->getStorage();
 			if ($storage && $storage->instanceOfStorage('\OCP\Files\Storage\ILockingStorage')) {
@@ -2011,6 +2061,7 @@
 				);
 			}
 		}
+		}
 
 		return true;
 	}
@@ -2033,6 +2084,7 @@
 		}
 
 		$mount = $this->getMountForLock($absolutePath, $lockMountPoint);
+		if ($mount) {
 		$storage = $mount->getStorage();
 		if ($storage && $storage->instanceOfStorage('\OCP\Files\Storage\ILockingStorage')) {
 			$storage->releaseLock(
@@ -2041,6 +2093,7 @@
 				$this->lockingProvider
 			);
 		}
+		}
 
 		return true;
 	}
@@ -2114,7 +2167,7 @@
 			return ($pathSegments[2] === 'files') && (count($pathSegments) > 3);
 		}
 
-		return !str_starts_with($path, '/appdata_');
+		return strpos($path, '/appdata_') !== 0;
 	}
 
 	/**
@@ -2135,9 +2188,9 @@
 		// "$user", "files", "path/to/dir"
 		if (!isset($parts[1]) || $parts[1] !== 'files') {
 			$this->logger->error(
-				'$absolutePath must be relative to "files", value is "{absolutePath}"',
+				'$absolutePath must be relative to "files", value is "%s"',
 				[
-					'absolutePath' => $absolutePath,
+					$absolutePath
 				]
 			);
 			throw new \InvalidArgumentException('$absolutePath must be relative to "files"');
@@ -2160,7 +2213,7 @@
 			throw new NotFoundException($this->getAbsolutePath($filename) . ' not found');
 		}
 		$uid = $info->getOwner()->getUID();
-		if ($uid != \OC_User::getUser()) {
+		if ($uid != \OCP\User::getUser()) {
 			Filesystem::initMountPoints($uid);
 			$ownerView = new View('/' . $uid . '/files');
 			try {
