--- /var/ida/nextcloud-new/apps/dav/lib/Connector/Sabre/File.php	2024-11-05 08:30:08.312702417 +0000
+++ /var/ida/nextcloud-old/apps/dav/lib/Connector/Sabre/File.php	2024-02-20 10:11:36.516433908 +0000
@@ -1,10 +1,42 @@
 <?php
-
 /**
- * SPDX-FileCopyrightText: 2016-2024 Nextcloud GmbH and Nextcloud contributors
- * SPDX-FileCopyrightText: 2016 ownCloud, Inc.
- * SPDX-License-Identifier: AGPL-3.0-only
+ * @copyright Copyright (c) 2016, ownCloud, Inc.
+ *
+ * @author Bart Visscher <bartv@thisnet.nl>
+ * @author Björn Schießle <bjoern@schiessle.org>
+ * @author Christoph Wurst <christoph@winzerhof-wurst.at>
+ * @author Daniel Calviño Sánchez <danxuliu@gmail.com>
+ * @author Jakob Sack <mail@jakobsack.de>
+ * @author Jan-Philipp Litza <jplitza@users.noreply.github.com>
+ * @author Joas Schilling <coding@schilljs.com>
+ * @author Jörn Friedrich Dreyer <jfd@butonic.de>
+ * @author Julius Härtl <jus@bitgrid.net>
+ * @author Lukas Reschke <lukas@statuscode.ch>
+ * @author Morris Jobke <hey@morrisjobke.de>
+ * @author Owen Winkler <a_github@midnightcircus.com>
+ * @author Robin Appelman <robin@icewind.nl>
+ * @author Roeland Jago Douma <roeland@famdouma.nl>
+ * @author Semih Serhat Karakaya <karakayasemi@itu.edu.tr>
+ * @author Stefan Schneider <stefan.schneider@squareweave.com.au>
+ * @author Thomas Müller <thomas.mueller@tmit.eu>
+ * @author Vincent Petry <vincent@nextcloud.com>
+ *
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program. If not, see <http://www.gnu.org/licenses/>
+ *
  */
+
 namespace OCA\DAV\Connector\Sabre;
 
 use Icewind\Streams\CallbackWrapper;
@@ -12,8 +44,6 @@
 use OC\Files\Filesystem;
 use OC\Files\Stream\HashWrapper;
 use OC\Files\View;
-use OCA\DAV\AppInfo\Application;
-use OCA\DAV\Connector\Sabre\Exception\BadGateway;
 use OCA\DAV\Connector\Sabre\Exception\EntityTooLarge;
 use OCA\DAV\Connector\Sabre\Exception\FileLocked;
 use OCA\DAV\Connector\Sabre\Exception\Forbidden as DAVForbiddenException;
@@ -30,50 +60,51 @@
 use OCP\Files\NotPermittedException;
 use OCP\Files\Storage;
 use OCP\Files\StorageNotAvailableException;
-use OCP\IL10N;
-use OCP\IRequest;
-use OCP\L10N\IFactory as IL10NFactory;
+use OCP\ILogger;
 use OCP\Lock\ILockingProvider;
 use OCP\Lock\LockedException;
 use OCP\Share\IManager;
-use Psr\Log\LoggerInterface;
 use Sabre\DAV\Exception;
 use Sabre\DAV\Exception\BadRequest;
 use Sabre\DAV\Exception\Forbidden;
 use Sabre\DAV\Exception\NotFound;
+use Sabre\DAV\Exception\NotImplemented;
 use Sabre\DAV\Exception\ServiceUnavailable;
 use Sabre\DAV\IFile;
+use OCA\IDA\Controller\DataChangeController;
+use OCP\Util;
 
 class File extends Node implements IFile {
-	protected IRequest $request;
-	protected IL10N $l10n;
+	protected $request;
+	protected $idaUser = null;
+	protected $idaMode = 'API';
 
 	/**
 	 * Sets up the node, expects a full path name
 	 *
 	 * @param \OC\Files\View $view
 	 * @param \OCP\Files\FileInfo $info
-	 * @param ?\OCP\Share\IManager $shareManager
-	 * @param ?IRequest $request
-	 * @param ?IL10N $l10n
+	 * @param \OCP\Share\IManager $shareManager
+	 * @param \OC\AppFramework\Http\Request $request
 	 */
-	public function __construct(View $view, FileInfo $info, ?IManager $shareManager = null, ?IRequest $request = null, ?IL10N $l10n = null) {
+	public function __construct(View $view, FileInfo $info, IManager $shareManager = null, Request $request = null) {
 		parent::__construct($view, $info, $shareManager);
 
-		if ($l10n) {
-			$this->l10n = $l10n;
-		} else {
-			// Querying IL10N directly results in a dependency loop
-			/** @var IL10NFactory $l10nFactory */
-			$l10nFactory = \OC::$server->get(IL10NFactory::class);
-			$this->l10n = $l10nFactory->get(Application::APP_ID);
-		}
-
 		if (isset($request)) {
 			$this->request = $request;
 		} else {
-			$this->request = \OC::$server->get(IRequest::class);
+			$this->request = \OC::$server->getRequest();
+		}
+
+		//Util::writeLog('ida', 'File init: server=' . json_encode($_SERVER), \OCP\Util::DEBUG);
+		if (isset($_SERVER['HTTP_IDA_AUTHENTICATED_USER'])) {
+			$this->idaUser = $_SERVER['HTTP_IDA_AUTHENTICATED_USER'];
+		}
+		if (isset($_SERVER['HTTP_IDA_MODE'])) {
+			$values = explode(',', $_SERVER['HTTP_IDA_MODE']);
+			$this->idaMode = $values[0];
 		}
+		Util::writeLog('ida', 'File init: idaUser=' . $this->idaUser . ' idaMode=' . $this->idaMode, \OCP\Util::DEBUG);
 	}
 
 	/**
@@ -93,7 +124,7 @@
 	 * different object on a subsequent GET you are strongly recommended to not
 	 * return an ETag, and just return null.
 	 *
-	 * @param resource|string $data
+	 * @param resource $data
 	 *
 	 * @throws Forbidden
 	 * @throws UnsupportedMediaType
@@ -107,18 +138,97 @@
 	public function put($data) {
 		try {
 			$exists = $this->fileView->file_exists($this->path);
-			if ($exists && !$this->info->isUpdateable()) {
+			if ($this->info && $exists && !$this->info->isUpdateable()) {
 				throw new Forbidden();
 			}
 		} catch (StorageNotAvailableException $e) {
-			throw new ServiceUnavailable($this->l10n->t('File is not updatable: %1$s', [$e->getMessage()]));
+			throw new ServiceUnavailable("File is not updatable: " . $e->getMessage());
 		}
 
 		// verify path of the target
 		$this->verifyPath();
 
+		// Special handling for zero size files
+		$zero_size = false;
+		try {
+			$filesize   = false;
+			$headers    = null;
+			$firstbyte  = null;
+			$test_basis = null;
+		
+			// Retrieve stream metadata
+			$metadata = stream_get_meta_data($data);
+
+			if ($metadata != null && is_array($metadata) && isset($metadata['uri'])) {
+				// First, we'll attempt to get the filesize based on the URI defined in the
+				// stream metadata, assuming the stream wrapper type supports os.filesize;
+				// which if not, it will either return false or throw an exception
+				$test_basis = 'filesize-stat';
+				try {
+				    $file_uri = $metadata['uri'];
+					$filesize = @filesize($file_uri);
+					if ($filesize === 0) {
+						$zero_size = true;
+					}
+				} catch (Exception $e) {
+					$filesize = false;
+				}
+			}
+			if ($filesize === false) {
+				// If we're here, then either no URI was defined or the stream wrapper type does not
+				// support os.filesize, so we'll try to get the size from the content length header,
+				// if it exists
+				$test_basis = 'content-length-header';
+				try {
+				    $headers = @get_headers((string)$data, 1);
+				    if ($headers != null && is_array($headers) && isset($headers['Content-Length'])) {
+					    $filesize = (int)$headers['Content-Length'];
+					    if ($filesize === 0) {
+						    $zero_size = true;
+					    }
+				    }
+				} catch (Exception $e) {
+					$filesize = false;
+				}
+			}
+			if ($filesize === false) {
+				// OK, last recourse is to actually read from the stream, but only if it 
+				// is seekable and thus can be reset to the beginning so there is no loss
+				// of data during the actual copy operation...
+				$test_basis = 'read-first-byte';
+				try {
+				    if (isset($metadata['seekable']) && $metadata['seekable'] === true) {
+					    $firstbyte = @fread($data, 1);
+					    @fseek($data, 0);
+					    if (strlen($firstbyte) === 0) {
+						    $zero_size = true;
+					    }
+				    }
+				} catch (Exception $e) { ; }
+			}
+			\OC::$server->getLogger()->debug('ZERO_SIZE_CHECK: '
+			. ' metadata: '   . json_encode($metadata)
+			. ' headers: '    . json_encode($headers)
+			. ' filesize: '   . json_encode($filesize)
+			. ' firstbyte: '  . json_encode(strlen($firstbyte))
+			. ' zero_size: '  . json_encode($zero_size)
+			. ' test_basis: ' . $test_basis);
+		} catch (Exception $e) {
+			\OC::$server->getLogger()->debug('ZERO_SIZE_CHECK: Error: ' . $e->getMessage());
+		}
+		
+		// chunked handling
+		if (isset($_SERVER['HTTP_OC_CHUNKED'])) {
+			try {
+				$result = $this->createFileChunked($data);
+				return $result;
+			} catch (\Exception $e) {
+				$this->convertToSabreException($e);
+			}
+		}
+
 		/** @var Storage $partStorage */
-		[$partStorage] = $this->fileView->resolvePath($this->path);
+		list($partStorage) = $this->fileView->resolvePath($this->path);
 		$needsPartFile = $partStorage->needsPartFile() && (strlen($this->path) > 1);
 
 		$view = \OC\Files\Filesystem::getView();
@@ -136,34 +246,18 @@
 			$partFilePath = $this->path;
 
 			if ($view && !$this->emitPreHooks($exists)) {
-				throw new Exception($this->l10n->t('Could not write to final file, canceled by hook'));
+				throw new Exception('Could not write to final file, canceled by hook');
 			}
 		}
 
 		// the part file and target file might be on a different storage in case of a single file storage (e.g. single file share)
 		/** @var \OC\Files\Storage\Storage $partStorage */
-		[$partStorage, $internalPartPath] = $this->fileView->resolvePath($partFilePath);
+		list($partStorage, $internalPartPath) = $this->fileView->resolvePath($partFilePath);
 		/** @var \OC\Files\Storage\Storage $storage */
-		[$storage, $internalPath] = $this->fileView->resolvePath($this->path);
+		list($storage, $internalPath) = $this->fileView->resolvePath($this->path);
 		try {
 			if (!$needsPartFile) {
-				try {
 					$this->changeLock(ILockingProvider::LOCK_EXCLUSIVE);
-				} catch (LockedException $e) {
-					// during very large uploads, the shared lock we got at the start might have been expired
-					// meaning that the above lock can fail not just only because somebody else got a shared lock
-					// or because there is no existing shared lock to make exclusive
-					//
-					// Thus we try to get a new exclusive lock, if the original lock failed because of a different shared
-					// lock this will still fail, if our original shared lock expired the new lock will be successful and
-					// the entire operation will be safe
-
-					try {
-						$this->acquireLock(ILockingProvider::LOCK_EXCLUSIVE);
-					} catch (LockedException $ex) {
-						throw new FileLocked($e->getMessage(), $e->getCode(), $e);
-					}
-				}
 			}
 
 			if (!is_resource($data)) {
@@ -175,26 +269,15 @@
 				$data = $tmpData;
 			}
 
-			if ($this->request->getHeader('X-HASH') !== '') {
-				$hash = $this->request->getHeader('X-HASH');
-				if ($hash === 'all' || $hash === 'md5') {
 					$data = HashWrapper::wrap($data, 'md5', function ($hash) {
 						$this->header('X-Hash-MD5: ' . $hash);
 					});
-				}
-
-				if ($hash === 'all' || $hash === 'sha1') {
 					$data = HashWrapper::wrap($data, 'sha1', function ($hash) {
 						$this->header('X-Hash-SHA1: ' . $hash);
 					});
-				}
-
-				if ($hash === 'all' || $hash === 'sha256') {
 					$data = HashWrapper::wrap($data, 'sha256', function ($hash) {
 						$this->header('X-Hash-SHA256: ' . $hash);
 					});
-				}
-			}
 
 			if ($partStorage->instanceOfStorage(Storage\IWriteStreamStorage::class)) {
 				$isEOF = false;
@@ -208,11 +291,8 @@
 					$count = $partStorage->writeStream($internalPartPath, $wrappedData);
 				} catch (GenericFileException $e) {
 					$result = false;
-				} catch (BadGateway $e) {
-					throw $e;
 				}
 
-
 				if ($result === false) {
 					$result = $isEOF;
 					if (is_resource($wrappedData)) {
@@ -222,58 +302,46 @@
 			} else {
 				$target = $partStorage->fopen($internalPartPath, 'wb');
 				if ($target === false) {
-					\OC::$server->get(LoggerInterface::class)->error('\OC\Files\Filesystem::fopen() failed', ['app' => 'webdav']);
+					\OC::$server->getLogger()->error('\OC\Files\Filesystem::fopen() failed', ['app' => 'webdav']);
 					// because we have no clue about the cause we can only throw back a 500/Internal Server Error
-					throw new Exception($this->l10n->t('Could not write file contents'));
+					throw new Exception('Could not write file contents');
 				}
-				[$count, $result] = \OC_Helper::streamCopy($data, $target);
+				list($count, $result) = \OC_Helper::streamCopy($data, $target);
 				fclose($target);
 			}
 
+			// Special handling for zero size files
+			if ($zero_size === true && $count === 0) {
+				$result = true;
+			}
+
 			if ($result === false) {
 				$expected = -1;
-				$lengthHeader = $this->request->getHeader('content-length');
-				if ($lengthHeader) {
-					$expected = (int)$lengthHeader;
-				}
-				if ($expected !== 0) {
-					throw new Exception(
-						$this->l10n->t(
-							'Error while copying file to target location (copied: %1$s, expected filesize: %2$s)',
-							[
-								$this->l10n->n('%n byte', '%n bytes', $count),
-								$this->l10n->n('%n byte', '%n bytes', $expected),
-							],
-						)
-					);
+				if (isset($_SERVER['CONTENT_LENGTH'])) {
+					$expected = $_SERVER['CONTENT_LENGTH'];
+				}
+				if ($expected !== "0") {
+					throw new Exception('Error while copying file to target location (copied bytes: ' . $count . ', expected filesize: ' . $expected . ' )');
 				}
 			}
 
 			// if content length is sent by client:
 			// double check if the file was fully received
 			// compare expected and actual size
-			$lengthHeader = $this->request->getHeader('content-length');
-			if ($lengthHeader && $this->request->getMethod() === 'PUT') {
-				$expected = (int)$lengthHeader;
+			if (isset($_SERVER['CONTENT_LENGTH']) && $_SERVER['REQUEST_METHOD'] === 'PUT') {
+				$expected = (int)$_SERVER['CONTENT_LENGTH'];
 				if ($count !== $expected) {
-					throw new BadRequest(
-						$this->l10n->t(
-							'Expected filesize of %1$s but read (from Nextcloud client) and wrote (to Nextcloud storage) %2$s. Could either be a network problem on the sending side or a problem writing to the storage on the server side.',
-							[
-								$this->l10n->n('%n byte', '%n bytes', $expected),
-								$this->l10n->n('%n byte', '%n bytes', $count),
-							],
-						)
-					);
+					throw new BadRequest('Expected filesize of ' . $expected . ' bytes but read (from Nextcloud client) and wrote (to Nextcloud storage) ' . $count . ' bytes. Could either be a network problem on the sending side or a problem writing to the storage on the server side.');
 				}
 			}
 		} catch (\Exception $e) {
+			$context = [];
+
 			if ($e instanceof LockedException) {
-				\OC::$server->get(LoggerInterface::class)->debug($e->getMessage(), ['exception' => $e]);
-			} else {
-				\OC::$server->get(LoggerInterface::class)->error($e->getMessage(), ['exception' => $e]);
+				$context['level'] = ILogger::DEBUG;
 			}
 
+			\OC::$server->getLogger()->logException($e, $context);
 			if ($needsPartFile) {
 				$partStorage->unlink($internalPartPath);
 			}
@@ -284,7 +352,7 @@
 			if ($needsPartFile) {
 				if ($view && !$this->emitPreHooks($exists)) {
 					$partStorage->unlink($internalPartPath);
-					throw new Exception($this->l10n->t('Could not rename part file to final file, canceled by hook'));
+					throw new Exception('Could not rename part file to final file, canceled by hook');
 				}
 				try {
 					$this->changeLock(ILockingProvider::LOCK_EXCLUSIVE);
@@ -312,8 +380,8 @@
 					$renameOkay = $storage->moveFromStorage($partStorage, $internalPartPath, $internalPath);
 					$fileExists = $storage->file_exists($internalPath);
 					if ($renameOkay === false || $fileExists === false) {
-						\OC::$server->get(LoggerInterface::class)->error('renaming part file to final file failed $renameOkay: ' . ($renameOkay ? 'true' : 'false') . ', $fileExists: ' . ($fileExists ? 'true' : 'false') . ')', ['app' => 'webdav']);
-						throw new Exception($this->l10n->t('Could not rename part file to final file'));
+						\OC::$server->getLogger()->error('renaming part file to final file failed $renameOkay: ' . ($renameOkay ? 'true' : 'false') . ', $fileExists: ' . ($fileExists ? 'true' : 'false') . ')', ['app' => 'webdav']);
+						throw new Exception('Could not rename part file to final file');
 					}
 				} catch (ForbiddenException $ex) {
 					if (!$ex->getRetry()) {
@@ -336,9 +404,8 @@
 			}
 
 			// allow sync clients to send the mtime along in a header
-			$mtimeHeader = $this->request->getHeader('x-oc-mtime');
-			if ($mtimeHeader !== '') {
-				$mtime = $this->sanitizeMtime($mtimeHeader);
+			if (isset($this->request->server['HTTP_X_OC_MTIME'])) {
+				$mtime = $this->sanitizeMtime($this->request->server['HTTP_X_OC_MTIME']);
 				if ($this->fileView->touch($this->path, $mtime)) {
 					$this->header('X-OC-MTime: accepted');
 				}
@@ -349,9 +416,8 @@
 			];
 
 			// allow sync clients to send the creation time along in a header
-			$ctimeHeader = $this->request->getHeader('x-oc-ctime');
-			if ($ctimeHeader) {
-				$ctime = $this->sanitizeMtime($ctimeHeader);
+			if (isset($this->request->server['HTTP_X_OC_CTIME'])) {
+				$ctime = $this->sanitizeMtime($this->request->server['HTTP_X_OC_CTIME']);
 				$fileInfoUpdate['creation_time'] = $ctime;
 				$this->header('X-OC-CTime: accepted');
 			}
@@ -364,17 +430,20 @@
 
 			$this->refreshInfo();
 
-			$checksumHeader = $this->request->getHeader('oc-checksum');
-			if ($checksumHeader) {
-				$checksum = trim($checksumHeader);
-				$this->setChecksum($checksum);
+			if (isset($this->request->server['HTTP_OC_CHECKSUM'])) {
+				$checksum = trim($this->request->server['HTTP_OC_CHECKSUM']);
+				$this->fileView->putFileInfo($this->path, ['checksum' => $checksum]);
+				$this->refreshInfo();
 			} elseif ($this->getChecksum() !== null && $this->getChecksum() !== '') {
-				$this->setChecksum('');
+				$this->fileView->putFileInfo($this->path, ['checksum' => '']);
+				$this->refreshInfo();
 			}
 		} catch (StorageNotAvailableException $e) {
-			throw new ServiceUnavailable($this->l10n->t('Failed to check file size: %1$s', [$e->getMessage()]), 0, $e);
+			throw new ServiceUnavailable("Failed to check file size: " . $e->getMessage(), 0, $e);
 		}
 
+        DataChangeController::processNextcloudOperation('add', $this->path, null, $this->idaUser, $this->idaMode);
+
 		return '"' . $this->info->getEtag() . '"';
 	}
 
@@ -387,15 +456,14 @@
 		}
 	}
 
-	private function emitPreHooks(bool $exists, ?string $path = null): bool {
+	/**
+	 * @param string $path
+	 */
+	private function emitPreHooks($exists, $path = null) {
 		if (is_null($path)) {
 			$path = $this->path;
 		}
 		$hookPath = Filesystem::getView()->getRelativePath($this->fileView->getAbsolutePath($path));
-		if ($hookPath === null) {
-			// We only trigger hooks from inside default view
-			return true;
-		}
 		$run = true;
 
 		if (!$exists) {
@@ -416,15 +484,14 @@
 		return $run;
 	}
 
-	private function emitPostHooks(bool $exists, ?string $path = null): void {
+	/**
+	 * @param string $path
+	 */
+	private function emitPostHooks($exists, $path = null) {
 		if (is_null($path)) {
 			$path = $this->path;
 		}
 		$hookPath = Filesystem::getView()->getRelativePath($this->fileView->getAbsolutePath($path));
-		if ($hookPath === null) {
-			// We only trigger hooks from inside default view
-			return;
-		}
 		if (!$exists) {
 			\OC_Hook::emit(\OC\Files\Filesystem::CLASSNAME, \OC\Files\Filesystem::signal_post_create, [
 				\OC\Files\Filesystem::signal_param_path => $hookPath
@@ -458,27 +525,15 @@
 			} catch (\Exception $e) {
 				$this->convertToSabreException($e);
 			}
-
 			if ($res === false) {
-				throw new ServiceUnavailable($this->l10n->t('Could not open file'));
-			}
-
-			// comparing current file size with the one in DB
-			// if different, fix DB and refresh cache.
-			if ($this->getSize() !== $this->fileView->filesize($this->getPath())) {
-				$logger = \OC::$server->get(LoggerInterface::class);
-				$logger->warning('fixing cached size of file id=' . $this->getId());
-
-				$this->getFileInfo()->getStorage()->getUpdater()->update($this->getFileInfo()->getInternalPath());
-				$this->refreshInfo();
+				throw new ServiceUnavailable("Could not open file");
 			}
-
 			return $res;
 		} catch (GenericEncryptionException $e) {
 			// returning 503 will allow retry of the operation at a later point in time
-			throw new ServiceUnavailable($this->l10n->t('Encryption not ready: %1$s', [$e->getMessage()]));
+			throw new ServiceUnavailable("Encryption not ready: " . $e->getMessage());
 		} catch (StorageNotAvailableException $e) {
-			throw new ServiceUnavailable($this->l10n->t('Failed to open file: %1$s', [$e->getMessage()]));
+			throw new ServiceUnavailable("Failed to open file: " . $e->getMessage());
 		} catch (ForbiddenException $ex) {
 			throw new DAVForbiddenException($ex->getMessage(), $ex->getRetry());
 		} catch (LockedException $e) {
@@ -503,7 +558,7 @@
 				throw new Forbidden();
 			}
 		} catch (StorageNotAvailableException $e) {
-			throw new ServiceUnavailable($this->l10n->t('Failed to unlink: %1$s', [$e->getMessage()]));
+			throw new ServiceUnavailable("Failed to unlink: " . $e->getMessage());
 		} catch (ForbiddenException $ex) {
 			throw new DAVForbiddenException($ex->getMessage(), $ex->getRetry());
 		} catch (LockedException $e) {
@@ -522,7 +577,7 @@
 		$mimeType = $this->info->getMimetype();
 
 		// PROPFIND needs to return the correct mime type, for consistency with the web UI
-		if ($this->request->getMethod() === 'PROPFIND') {
+		if (isset($_SERVER['REQUEST_METHOD']) && $_SERVER['REQUEST_METHOD'] === 'PROPFIND') {
 			return $mimeType;
 		}
 		return \OC::$server->getMimeTypeDetector()->getSecureMimeType($mimeType);
@@ -532,11 +587,11 @@
 	 * @return array|bool
 	 */
 	public function getDirectDownload() {
-		if (\OCP\Server::get(\OCP\App\IAppManager::class)->isEnabledForUser('encryption')) {
+		if (\OCP\App::isEnabled('encryption')) {
 			return [];
 		}
 		/** @var \OCP\Files\Storage $storage */
-		[$storage, $internalPath] = $this->fileView->resolvePath($this->path);
+		list($storage, $internalPath) = $this->fileView->resolvePath($this->path);
 		if (is_null($storage)) {
 			return [];
 		}
@@ -545,6 +600,126 @@
 	}
 
 	/**
+	 * @param resource $data
+	 * @return null|string
+	 * @throws Exception
+	 * @throws BadRequest
+	 * @throws NotImplemented
+	 * @throws ServiceUnavailable
+	 */
+	private function createFileChunked($data) {
+		list($path, $name) = \Sabre\Uri\split($this->path);
+
+		$info = \OC_FileChunking::decodeName($name);
+		if (empty($info)) {
+			throw new NotImplemented('Invalid chunk name');
+		}
+
+		$chunk_handler = new \OC_FileChunking($info);
+		$bytesWritten = $chunk_handler->store($info['index'], $data);
+
+		//detect aborted upload
+		if (isset($_SERVER['REQUEST_METHOD']) && $_SERVER['REQUEST_METHOD'] === 'PUT') {
+			if (isset($_SERVER['CONTENT_LENGTH'])) {
+				$expected = (int)$_SERVER['CONTENT_LENGTH'];
+				if ($bytesWritten !== $expected) {
+					$chunk_handler->remove($info['index']);
+					throw new BadRequest('Expected filesize of ' . $expected . ' bytes but read (from Nextcloud client) and wrote (to Nextcloud storage) ' . $bytesWritten . ' bytes. Could either be a network problem on the sending side or a problem writing to the storage on the server side.');
+				}
+			}
+		}
+
+		if ($chunk_handler->isComplete()) {
+			/** @var Storage $storage */
+			list($storage,) = $this->fileView->resolvePath($path);
+			$needsPartFile = $storage->needsPartFile();
+			$partFile = null;
+
+			$targetPath = $path . '/' . $info['name'];
+			/** @var \OC\Files\Storage\Storage $targetStorage */
+			list($targetStorage, $targetInternalPath) = $this->fileView->resolvePath($targetPath);
+
+			$exists = $this->fileView->file_exists($targetPath);
+
+			try {
+				$this->fileView->lockFile($targetPath, ILockingProvider::LOCK_SHARED);
+
+				$this->emitPreHooks($exists, $targetPath);
+				$this->fileView->changeLock($targetPath, ILockingProvider::LOCK_EXCLUSIVE);
+				/** @var \OC\Files\Storage\Storage $targetStorage */
+				list($targetStorage, $targetInternalPath) = $this->fileView->resolvePath($targetPath);
+
+				if ($needsPartFile) {
+					// we first assembly the target file as a part file
+					$partFile = $this->getPartFileBasePath($path . '/' . $info['name']) . '.ocTransferId' . $info['transferid'] . '.part';
+					/** @var \OC\Files\Storage\Storage $targetStorage */
+					list($partStorage, $partInternalPath) = $this->fileView->resolvePath($partFile);
+
+
+					$chunk_handler->file_assemble($partStorage, $partInternalPath);
+
+					// here is the final atomic rename
+					$renameOkay = $targetStorage->moveFromStorage($partStorage, $partInternalPath, $targetInternalPath);
+					$fileExists = $targetStorage->file_exists($targetInternalPath);
+					if ($renameOkay === false || $fileExists === false) {
+						\OC::$server->getLogger()->error('\OC\Files\Filesystem::rename() failed', ['app' => 'webdav']);
+						// only delete if an error occurred and the target file was already created
+						if ($fileExists) {
+							// set to null to avoid double-deletion when handling exception
+							// stray part file
+							$partFile = null;
+							$targetStorage->unlink($targetInternalPath);
+						}
+						$this->fileView->changeLock($targetPath, ILockingProvider::LOCK_SHARED);
+						throw new Exception('Could not rename part file assembled from chunks');
+					}
+				} else {
+					// assemble directly into the final file
+					$chunk_handler->file_assemble($targetStorage, $targetInternalPath);
+				}
+
+				// allow sync clients to send the mtime along in a header
+				if (isset($this->request->server['HTTP_X_OC_MTIME'])) {
+					$mtime = $this->sanitizeMtime($this->request->server['HTTP_X_OC_MTIME']);
+					if ($targetStorage->touch($targetInternalPath, $mtime)) {
+						$this->header('X-OC-MTime: accepted');
+					}
+				}
+
+				// since we skipped the view we need to scan and emit the hooks ourselves
+				$targetStorage->getUpdater()->update($targetInternalPath);
+
+				$this->fileView->changeLock($targetPath, ILockingProvider::LOCK_SHARED);
+
+				$this->emitPostHooks($exists, $targetPath);
+
+				// FIXME: should call refreshInfo but can't because $this->path is not the of the final file
+				$info = $this->fileView->getFileInfo($targetPath);
+
+				if (isset($this->request->server['HTTP_OC_CHECKSUM'])) {
+					$checksum = trim($this->request->server['HTTP_OC_CHECKSUM']);
+					$this->fileView->putFileInfo($targetPath, ['checksum' => $checksum]);
+				} elseif ($info->getChecksum() !== null && $info->getChecksum() !== '') {
+					$this->fileView->putFileInfo($this->path, ['checksum' => '']);
+				}
+
+				$this->fileView->unlockFile($targetPath, ILockingProvider::LOCK_SHARED);
+
+                DataChangeController::processNextcloudOperation('add', $this->path, null, $this->idaUser, $this->idaMode);
+
+				return $info->getEtag();
+			} catch (\Exception $e) {
+				if ($partFile !== null) {
+					$targetStorage->unlink($targetInternalPath);
+				}
+				$this->convertToSabreException($e);
+			}
+		}
+
+		return null;
+	}
+
+	/**
 	 * Convert the given exception to a SabreException instance
 	 *
 	 * @param \Exception $e
@@ -582,13 +757,13 @@
 		}
 		if ($e instanceof GenericEncryptionException) {
 			// returning 503 will allow retry of the operation at a later point in time
-			throw new ServiceUnavailable($this->l10n->t('Encryption not ready: %1$s', [$e->getMessage()]), 0, $e);
+			throw new ServiceUnavailable('Encryption not ready: ' . $e->getMessage(), 0, $e);
 		}
 		if ($e instanceof StorageNotAvailableException) {
-			throw new ServiceUnavailable($this->l10n->t('Failed to write file contents: %1$s', [$e->getMessage()]), 0, $e);
+			throw new ServiceUnavailable('Failed to write file contents: ' . $e->getMessage(), 0, $e);
 		}
 		if ($e instanceof NotFoundException) {
-			throw new NotFound($this->l10n->t('File not found: %1$s', [$e->getMessage()]), 0, $e);
+			throw new NotFound('File not found: ' . $e->getMessage(), 0, $e);
 		}
 
 		throw new \Sabre\DAV\Exception($e->getMessage(), 0, $e);
@@ -597,28 +772,15 @@
 	/**
 	 * Get the checksum for this file
 	 *
-	 * @return string|null
+	 * @return string
 	 */
 	public function getChecksum() {
 		return $this->info->getChecksum();
 	}
 
-	public function setChecksum(string $checksum) {
-		$this->fileView->putFileInfo($this->path, ['checksum' => $checksum]);
-		$this->refreshInfo();
-	}
-
 	protected function header($string) {
 		if (!\OC::$CLI) {
 			\header($string);
 		}
 	}
-
-	public function hash(string $type) {
-		return $this->fileView->hash($type, $this->path);
-	}
-
-	public function getNode(): \OCP\Files\File {
-		return $this->node;
-	}
 }
