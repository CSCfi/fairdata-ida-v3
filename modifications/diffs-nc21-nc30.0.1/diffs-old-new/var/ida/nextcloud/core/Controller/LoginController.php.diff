--- /var/ida/nextcloud-new/core/Controller/LoginController.php	2024-11-05 08:30:08.263702247 +0000
+++ /var/ida/nextcloud-old/core/Controller/LoginController.php	2024-02-20 10:11:38.365440176 +0000
@@ -1,80 +1,149 @@
 <?php
-
-declare(strict_types=1);
-
 /**
- * SPDX-FileCopyrightText: 2016-2024 Nextcloud GmbH and Nextcloud contributors
- * SPDX-FileCopyrightText: 2016 ownCloud, Inc.
- * SPDX-License-Identifier: AGPL-3.0-only
+ * @copyright Copyright (c) 2017, Sandro Lutz <sandro.lutz@temparus.ch>
+ * @copyright Copyright (c) 2016 Joas Schilling <coding@schilljs.com>
+ * @copyright Copyright (c) 2016, ownCloud, Inc.
+ *
+ * @author Christoph Wurst <christoph@winzerhof-wurst.at>
+ * @author Daniel Kesselberg <mail@danielkesselberg.de>
+ * @author Joas Schilling <coding@schilljs.com>
+ * @author John Molakvoæ (skjnldsv) <skjnldsv@protonmail.com>
+ * @author Julius Härtl <jus@bitgrid.net>
+ * @author Lukas Reschke <lukas@statuscode.ch>
+ * @author Michael Weimann <mail@michael-weimann.eu>
+ * @author Rayn0r <andrew@ilpss8.myfirewall.org>
+ * @author Roeland Jago Douma <roeland@famdouma.nl>
+ *
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program. If not, see <http://www.gnu.org/licenses/>
+ *
  */
+
 namespace OC\Core\Controller;
 
 use OC\AppFramework\Http\Request;
 use OC\Authentication\Login\Chain;
 use OC\Authentication\Login\LoginData;
 use OC\Authentication\WebAuthn\Manager as WebAuthnManager;
+use OC\Security\Bruteforce\Throttler;
 use OC\User\Session;
 use OC_App;
-use OCA\User_LDAP\Configuration;
-use OCA\User_LDAP\Helper;
-use OCP\App\IAppManager;
+use OC_Util;
 use OCP\AppFramework\Controller;
 use OCP\AppFramework\Http;
-use OCP\AppFramework\Http\Attribute\BruteForceProtection;
-use OCP\AppFramework\Http\Attribute\FrontpageRoute;
-use OCP\AppFramework\Http\Attribute\NoAdminRequired;
-use OCP\AppFramework\Http\Attribute\NoCSRFRequired;
-use OCP\AppFramework\Http\Attribute\OpenAPI;
-use OCP\AppFramework\Http\Attribute\PublicPage;
-use OCP\AppFramework\Http\Attribute\UseSession;
 use OCP\AppFramework\Http\DataResponse;
 use OCP\AppFramework\Http\RedirectResponse;
 use OCP\AppFramework\Http\TemplateResponse;
-use OCP\AppFramework\Services\IInitialState;
 use OCP\Defaults;
 use OCP\IConfig;
-use OCP\IL10N;
+use OCP\IInitialStateService;
+use OCP\ILogger;
 use OCP\IRequest;
 use OCP\ISession;
 use OCP\IURLGenerator;
 use OCP\IUser;
 use OCP\IUserManager;
-use OCP\Notification\IManager;
-use OCP\Security\Bruteforce\IThrottler;
+use OCP\IUserSession;
 use OCP\Util;
 
 class LoginController extends Controller {
 	public const LOGIN_MSG_INVALIDPASSWORD = 'invalidpassword';
 	public const LOGIN_MSG_USERDISABLED = 'userdisabled';
-	public const LOGIN_MSG_CSRFCHECKFAILED = 'csrfCheckFailed';
 
-	public function __construct(
-		?string $appName,
+	/** @var IUserManager */
+	private $userManager;
+	/** @var IConfig */
+	private $config;
+	/** @var ISession */
+	private $session;
+	/** @var IUserSession|Session */
+	private $userSession;
+	/** @var IURLGenerator */
+	private $urlGenerator;
+	/** @var ILogger */
+	private $logger;
+	/** @var Defaults */
+	private $defaults;
+	/** @var Throttler */
+	private $throttler;
+	/** @var Chain */
+	private $loginChain;
+	/** @var IInitialStateService */
+	private $initialStateService;
+	/** @var WebAuthnManager */
+	private $webAuthnManager;
+
+	public function __construct(?string $appName,
 		IRequest $request,
-		private IUserManager $userManager,
-		private IConfig $config,
-		private ISession $session,
-		private Session $userSession,
-		private IURLGenerator $urlGenerator,
-		private Defaults $defaults,
-		private IThrottler $throttler,
-		private IInitialState $initialState,
-		private WebAuthnManager $webAuthnManager,
-		private IManager $manager,
-		private IL10N $l10n,
-		private IAppManager $appManager,
-	) {
+								IUserManager $userManager,
+								IConfig $config,
+								ISession $session,
+								IUserSession $userSession,
+								IURLGenerator $urlGenerator,
+								ILogger $logger,
+								Defaults $defaults,
+								Throttler $throttler,
+								Chain $loginChain,
+								IInitialStateService $initialStateService,
+								WebAuthnManager $webAuthnManager) {
 		parent::__construct($appName, $request);
+		$this->userManager = $userManager;
+		$this->config = $config;
+		$this->session = $session;
+		$this->userSession = $userSession;
+		$this->urlGenerator = $urlGenerator;
+		$this->logger = $logger;
+		$this->defaults = $defaults;
+		$this->throttler = $throttler;
+		$this->loginChain = $loginChain;
+		$this->initialStateService = $initialStateService;
+		$this->webAuthnManager = $webAuthnManager;
 	}
 
 	/**
+	 * @NoAdminRequired
+	 * @UseSession
+	 *
 	 * @return RedirectResponse
 	 */
-	#[NoAdminRequired]
-	#[UseSession]
-	#[FrontpageRoute(verb: 'GET', url: '/logout')]
 	public function logout() {
+
+		// Log out of IDA.
+		//
+		// If login was via SSO, redirects to the Fairdata SSO so that the SSO session is
+		// terminated, ultimately being redirected back to the IDA home page.
+		//
+		// if login was via local Nextcloud authentication, redirects directly to the IDA
+		// home page.
+		
+		$uid = $this->userSession->getUser()->getUID();
+        $language = $this->config->getUserValue($uid, 'core', 'lang');
+		$redirect_url = $this->config->getSystemValue('IDA_HOME');
+
+		if ($this->config->getSystemValue('SSO_AUTHENTICATION') === true) {
+		    $domain = $this->config->getSystemValue('SSO_DOMAIN');
+			$prefix = preg_replace('/[^a-zA-Z0-9]/', '_', $domain);
+			if (isset($_COOKIE[$prefix . '_fd_sso_session_id'])) {
+			    $redirect_url = $this->config->getSystemValue('SSO_API') . '/logout?service=IDA&redirect_url=' . urlencode($redirect_url) . '&language=' . $language;
+		        Util::writeLog('ida', 'LoginController.php: logout: active SSO session cookie found', \OCP\Util::DEBUG);
+			}
+		}
+
+		Util::writeLog('ida', 'LoginController.php: logout: uid=' . $uid . ' redirect_url: ' . $redirect_url, \OCP\Util::DEBUG);
+
 		$loginToken = $this->request->getCookie('nc_token');
+
 		if (!is_null($loginToken)) {
 			$this->config->deleteUserValue($this->userSession->getUser()->getUID(), 'login_token', $loginToken);
 		}
@@ -78,63 +147,57 @@
 		if (!is_null($loginToken)) {
 			$this->config->deleteUserValue($this->userSession->getUser()->getUID(), 'login_token', $loginToken);
 		}
+
 		$this->userSession->logout();
 
-		$response = new RedirectResponse($this->urlGenerator->linkToRouteAbsolute(
-			'core.login.showLoginForm',
-			['clear' => true] // this param the code in login.js may be removed when the "Clear-Site-Data" is working in the browsers
-		));
+		$response = new RedirectResponse($redirect_url);
+		$response->addHeader('Clear-Site-Data', '"cache", "storage", "executionContexts"');
 
 		$this->session->set('clearingExecutionContexts', '1');
 		$this->session->close();
 
-		if (
-			$this->request->getServerProtocol() === 'https' &&
-			!$this->request->isUserAgent([Request::USER_AGENT_CHROME, Request::USER_AGENT_ANDROID_MOBILE_CHROME])
-		) {
-			$response->addHeader('Clear-Site-Data', '"cache", "storage"');
-		}
-
 		return $response;
 	}
 
 	/**
+	 * @PublicPage
+	 * @NoCSRFRequired
+	 * @UseSession
+	 *
 	 * @param string $user
 	 * @param string $redirect_url
 	 *
 	 * @return TemplateResponse|RedirectResponse
 	 */
-	#[NoCSRFRequired]
-	#[PublicPage]
-	#[UseSession]
-	#[OpenAPI(scope: OpenAPI::SCOPE_IGNORE)]
-	#[FrontpageRoute(verb: 'GET', url: '/login')]
-	public function showLoginForm(?string $user = null, ?string $redirect_url = null): Http\Response {
+	public function showLoginForm(string $user = null, string $redirect_url = null): Http\Response {
 		if ($this->userSession->isLoggedIn()) {
-			return new RedirectResponse($this->urlGenerator->linkToDefaultPageUrl());
+			return new RedirectResponse(OC_Util::getDefaultPageUrl());
 		}
 
+		$parameters = array();
 		$loginMessages = $this->session->get('loginMessages');
-		if (!$this->manager->isFairUseOfFreePushService()) {
-			if (!is_array($loginMessages)) {
-				$loginMessages = [[], []];
-			}
-			$loginMessages[1][] = $this->l10n->t('This community release of Nextcloud is unsupported and push notifications are limited.');
-		}
+		$errors = [];
+		$messages = [];
 		if (is_array($loginMessages)) {
-			[$errors, $messages] = $loginMessages;
-			$this->initialState->provideInitialState('loginMessages', $messages);
-			$this->initialState->provideInitialState('loginErrors', $errors);
+			list($errors, $messages) = $loginMessages;
+			$this->initialStateService->provideInitialState('core', 'loginMessages', $messages);
+			$this->initialStateService->provideInitialState('core', 'loginErrors', $errors);
 		}
 		$this->session->remove('loginMessages');
+		foreach ($errors as $value) {
+			$parameters[$value] = true;
+		}
+
+		$parameters['messages'] = $messages;
 
 		if ($user !== null && $user !== '') {
-			$this->initialState->provideInitialState('loginUsername', $user);
+			$this->initialStateService->provideInitialState('core', 'loginUsername', $user);
 		} else {
-			$this->initialState->provideInitialState('loginUsername', '');
+			$this->initialStateService->provideInitialState('core', 'loginUsername', '');
 		}
 
-		$this->initialState->provideInitialState(
+		$this->initialStateService->provideInitialState(
+			'core',
 			'loginAutocomplete',
 			$this->config->getSystemValue('login_form_autocomplete', true) === true
 		);
@@ -142,22 +205,19 @@
 		if (!empty($redirect_url)) {
 			[$url, ] = explode('?', $redirect_url);
 			if ($url !== $this->urlGenerator->linkToRoute('core.login.logout')) {
-				$this->initialState->provideInitialState('loginRedirectUrl', $redirect_url);
+				$this->initialStateService->provideInitialState('core', 'loginRedirectUrl', $redirect_url);
 			}
 		}
 
-		$this->initialState->provideInitialState(
+		$this->initialStateService->provideInitialState(
+			'core',
 			'loginThrottleDelay',
 			$this->throttler->getDelay($this->request->getRemoteAddress())
 		);
 
 		$this->setPasswordResetInitialState($user);
 
-		$this->setEmailStates();
-
-		$this->initialState->provideInitialState('webauthn-available', $this->webAuthnManager->isWebAuthnAvailable());
-
-		$this->initialState->provideInitialState('hideLoginForm', $this->config->getSystemValueBool('hide_login_form', false));
+		$this->initialStateService->provideInitialState('core', 'webauthn-available', $this->webAuthnManager->isWebAuthnAvailable());
 
 		// OpenGraph Support: http://ogp.me/
 		Util::addHeader('meta', ['property' => 'og:title', 'content' => Util::sanitizeHTML($this->defaults->getName())]);
@@ -169,18 +229,9 @@
 
 		$parameters = [
 			'alt_login' => OC_App::getAlternativeLogIns(),
-			'pageTitle' => $this->l10n->t('Login'),
 		];
-
-		$this->initialState->provideInitialState('countAlternativeLogins', count($parameters['alt_login']));
-		$this->initialState->provideInitialState('alternativeLogins', $parameters['alt_login']);
-		$this->initialState->provideInitialState('loginTimeout', $this->config->getSystemValueInt('login_form_timeout', 5 * 60));
-
 		return new TemplateResponse(
-			$this->appName,
-			'login',
-			$parameters,
-			TemplateResponse::RENDER_AS_GUEST,
+			$this->appName, 'login', $parameters, 'guest'
 		);
 	}
 
@@ -196,41 +247,22 @@
 			$user = null;
 		}
 
-		$passwordLink = $this->config->getSystemValueString('lost_password_link', '');
+		$passwordLink = $this->config->getSystemValue('lost_password_link', '');
 
-		$this->initialState->provideInitialState(
+		$this->initialStateService->provideInitialState(
+			'core',
 			'loginResetPasswordLink',
 			$passwordLink
 		);
 
-		$this->initialState->provideInitialState(
+		$this->initialStateService->provideInitialState(
+			'core',
 			'loginCanResetPassword',
 			$this->canResetPassword($passwordLink, $user)
 		);
 	}
 
 	/**
-	 * Sets the initial state of whether or not a user is allowed to login with their email
-	 * initial state is passed in the array of 1 for email allowed and 0 for not allowed
-	 */
-	private function setEmailStates(): void {
-		$emailStates = []; // true: can login with email, false otherwise - default to true
-
-		// check if user_ldap is enabled, and the required classes exist
-		if ($this->appManager->isAppLoaded('user_ldap')
-			&& class_exists(Helper::class)) {
-			$helper = \OCP\Server::get(Helper::class);
-			$allPrefixes = $helper->getServerConfigurationPrefixes();
-			// check each LDAP server the user is connected too
-			foreach ($allPrefixes as $prefix) {
-				$emailConfig = new Configuration($prefix);
-				array_push($emailStates, $emailConfig->__get('ldapLoginFilterEmail'));
-			}
-		}
-		$this->initialState->provideInitialState('emailStates', $emailStates);
-	}
-
-	/**
 	 * @param string|null $passwordLink
 	 * @param IUser|null $user
 	 *
@@ -242,6 +274,7 @@
 	 * @return bool
 	 */
 	private function canResetPassword(?string $passwordLink, ?IUser $user): bool {
+		return false;
 		if ($passwordLink === 'disabled') {
 			return false;
 		}
@@ -262,68 +295,48 @@
 			$location = $this->urlGenerator->getAbsoluteURL($redirectUrl);
 			// Deny the redirect if the URL contains a @
 			// This prevents unvalidated redirects like ?redirect_url=:user@domain.com
-			if (!str_contains($location, '@')) {
+			if (strpos($location, '@') === false) {
 				return new RedirectResponse($location);
 			}
 		}
-		return new RedirectResponse($this->urlGenerator->linkToDefaultPageUrl());
+		return new RedirectResponse(OC_Util::getDefaultPageUrl());
 	}
 
 	/**
+	 * @PublicPage
+	 * @UseSession
+	 * @NoCSRFRequired
+	 * @BruteForceProtection(action=login)
+	 *
+	 * @param string $user
+	 * @param string $password
+	 * @param string $redirect_url
+	 * @param string $timezone
+	 * @param string $timezone_offset
+	 *
 	 * @return RedirectResponse
 	 */
-	#[NoCSRFRequired]
-	#[PublicPage]
-	#[BruteForceProtection(action: 'login')]
-	#[UseSession]
-	#[OpenAPI(scope: OpenAPI::SCOPE_IGNORE)]
-	#[FrontpageRoute(verb: 'POST', url: '/login')]
-	public function tryLogin(Chain $loginChain,
-		string $user = '',
-		string $password = '',
-		?string $redirect_url = null,
+	public function tryLogin(string $user,
+							 string $password,
+							 string $redirect_url = null,
 		string $timezone = '',
 		string $timezone_offset = ''): RedirectResponse {
-		if (!$this->request->passesCSRFCheck()) {
-			if ($this->userSession->isLoggedIn()) {
 				// If the user is already logged in and the CSRF check does not pass then
 				// simply redirect the user to the correct page as required. This is the
-				// case when a user has already logged-in, in another tab.
+		// case when an user has already logged-in, in another tab.
+		if (!$this->request->passesCSRFCheck()) {
 				return $this->generateRedirect($redirect_url);
 			}
 
-			// Clear any auth remnants like cookies to ensure a clean login
-			// For the next attempt
-			$this->userSession->logout();
-			return $this->createLoginFailedResponse(
-				$user,
-				$user,
-				$redirect_url,
-				self::LOGIN_MSG_CSRFCHECKFAILED,
-				false,
-			);
-		}
-
-		$user = trim($user);
-
-		if (strlen($user) > 255) {
-			return $this->createLoginFailedResponse(
-				$user,
-				$user,
-				$redirect_url,
-				$this->l10n->t('Unsupported email length (>255)')
-			);
-		}
-
 		$data = new LoginData(
 			$this->request,
-			$user,
+			trim($user),
 			$password,
 			$redirect_url,
 			$timezone,
 			$timezone_offset
 		);
-		$result = $loginChain->process($data);
+		$result = $this->loginChain->process($data);
 		if (!$result->isSuccess()) {
 			return $this->createLoginFailedResponse(
 				$data->getUsername(),
@@ -350,12 +363,7 @@
 	 * @return RedirectResponse
 	 */
 	private function createLoginFailedResponse(
-		$user,
-		$originalUser,
-		$redirect_url,
-		string $loginMessage,
-		bool $throttle = true,
-	) {
+		$user, $originalUser, $redirect_url, string $loginMessage) {
 		// Read current user and append if possible we need to
 		// return the unmodified user otherwise we will leak the login name
 		$args = $user !== null ? ['user' => $originalUser, 'direct' => 1] : [];
@@ -365,9 +373,7 @@
 		$response = new RedirectResponse(
 			$this->urlGenerator->linkToRoute('core.login.showLoginForm', $args)
 		);
-		if ($throttle) {
 			$response->throttle(['user' => substr($user, 0, 64)]);
-		}
 		$this->session->set('loginMessages', [
 			[$loginMessage], []
 		]);
@@ -375,34 +381,27 @@
 	}
 
 	/**
-	 * Confirm the user password
-	 *
-	 * @license GNU AGPL version 3 or any later version
+	 * @NoAdminRequired
+	 * @UseSession
+	 * @BruteForceProtection(action=sudo)
 	 *
-	 * @param string $password The password of the user
+	 * @param string $password
 	 *
-	 * @return DataResponse<Http::STATUS_OK, array{lastLogin: int}, array{}>|DataResponse<Http::STATUS_FORBIDDEN, array<empty>, array{}>
+	 * @return DataResponse
+	 * @license GNU AGPL version 3 or any later version
 	 *
-	 * 200: Password confirmation succeeded
-	 * 403: Password confirmation failed
 	 */
-	#[NoAdminRequired]
-	#[BruteForceProtection(action: 'sudo')]
-	#[UseSession]
-	#[NoCSRFRequired]
-	#[FrontpageRoute(verb: 'POST', url: '/login/confirm')]
-	public function confirmPassword(string $password): DataResponse {
+	public function confirmPassword($password) {
 		$loginName = $this->userSession->getLoginName();
 		$loginResult = $this->userManager->checkPassword($loginName, $password);
 		if ($loginResult === false) {
 			$response = new DataResponse([], Http::STATUS_FORBIDDEN);
-			$response->throttle(['loginName' => $loginName]);
+			$response->throttle();
 			return $response;
 		}
 
 		$confirmTimestamp = time();
 		$this->session->set('last-password-confirm', $confirmTimestamp);
-		$this->throttler->resetDelay($this->request->getRemoteAddress(), 'sudo', ['loginName' => $loginName]);
 		return new DataResponse(['lastLogin' => $confirmTimestamp], Http::STATUS_OK);
 	}
 }
